<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bwrong的拾光]]></title>
  <link href="https://www.bwrong.cn/atom.xml" rel="self"/>
  <link href="https://www.bwrong.cn/"/>
  <updated>2025-04-18T13:05:28+08:00</updated>
  <id>https://www.bwrong.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[MCP（Model Context Protocol）入门与实践]]></title>
    <link href="https://www.bwrong.cn/17448568756381.html"/>
    <updated>2025-04-17T10:27:55+08:00</updated>
    <id>https://www.bwrong.cn/17448568756381.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E4%B8%80%E3%80%81mcp%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、MCP 基础概念</h2>
<h3><a id="1-1%E4%BB%80%E4%B9%88%E6%98%AF-mcp%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.1 什么是 MCP？</h3>
<p><strong>定义</strong>：MCP（Model Context Protocol，模型上下文协议）是由Anthropic公司于2024年底提出的一种<strong>开放标准协议</strong>，它标准化了应用程序如何为 LLM 提供上下文，旨在解决大型语言模型（LLM）与外部数据、工具之间的连接交互问题。它为AI应用提供了一种统一的、标准化的方式来访问和处理数据（实时数据、本地数据），解决了AI模型的数据孤岛问题，为 AI 应用提供了连接万物的接口，被誉为 &quot;AI 领域的 USB-C&quot;。<br />
<figure><img src="media/17448568756381/17449444076713.jpg" alt="" /></figure></p>
<p><strong>核心价值</strong>：</p>
<p>传统的AI模型面临几个关键挑战：</p>
<ul>
<li>知识时效性限制：模型只了解训练截止日期前的信息</li>
<li>专有数据访问困难：无法直接访问企业内部系统的数据</li>
<li>集成成本高昂：每接入一种新数据源，都需要定制专门的集成方案。传统上，将 AI 系统连接到外部工具涉及集成多个 API。每个 API 集成都意味着单独的代码、文档、身份验证方法、错误处理和维护。<br />
<figure><img src="media/17448568756381/17449445095592.jpg" alt="" /></figure></li>
</ul>
<p>MCP的核心优势：</p>
<ul>
<li>生态：MCP 提供很多现成的插件，你的 AI 可以直接使用。</li>
<li>统一性：不限制于特定的 AI 模型，任何支持 MCP 的模型都可以灵活切换。</li>
<li>数据安全：你的敏感数据留在自己的电脑上，自行决定上传那些数据。</li>
</ul>
<p>MCP 是 AI大模型 与数据（包括本地数据和互联网数据）之间的一座桥梁，通过 MCP 服务器和 MCP 客户端，大家只要都遵循这套协议，就能实现“万物互联”。比如，可以和数据和文件系统、开发工具、Web 和浏览器自动化、生产力和通信、各种社区生态能力全部集成，实现强大的协作工作能力。<br />
<figure><img src="media/17448568756381/17448608579279.jpg" alt="" /></figure></p>
<h3><a id="1-2%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.2 核心架构</h3>
<p><figure><img src="media/17448568756381/17449452410979.gif" alt="" /></figure></p>
<p>MCP 遵循客户端-服务器架构（client-server），其中包含以下几个核心概念：</p>
<ul>
<li><strong>MCP 主机（MCP Hosts）</strong>：发起请求的 LLM 应用程序（例如 Claude Desktop、IDE 或 AI 工具）。</li>
<li><strong>MCP 客户端（MCP Clients）</strong>：在主机程序内部，与 MCP server 保持 1:1 的连接。</li>
<li><strong>MCP 服务器（MCP Servers）</strong>：为 MCP client 提供上下文、工具和 prompt 信息。</li>
<li>本地资源（Local Resources）：本地计算机中可供 MCP server 安全访问的资源（例如文件、数据库）。</li>
<li>远程资源（Remote Resources）：MCP server 可以连接到的远程资源（例如通过 API）。</li>
</ul>
<p>其中，重点关注MCP Client和MCP Server。</p>
<p><strong>MCP Client</strong>：<br />
<figure><img src="media/17448568756381/17449452837237.jpg" alt="" /></figure></p>
<p>MCP client 充当 LLM 和 MCP server 之间的桥梁，MCP client 的工作流程如下：</p>
<p>❶ MCP client 首先从 MCP server 获取可用的工具列表。<br />
❷ 将用户的查询连同工具描述通过 function calling 一起发送给 LLM。<br />
❸ LLM 决定是否需要使用工具以及使用哪些工具。<br />
❹ 如果需要使用工具，大模型向MCP client发出请求，MCP client 会通过 MCP server 执行相应的工具调用。<br />
❺ MCP server处理请求，处理结果返回给MCP client<br />
❺ MCP client将结果发送回 LLM。<br />
❻ LLM 基于所有信息生成自然语言响应。<br />
❼ MCP Hosts将响应展示给用户。</p>
<p>Claude Desktop 和Cursor都支持了MCP Server接入能力，它们就是作为 MCP client来连接某个MCP Server感知和实现调用。</p>
<p><strong>MCP Server</strong>：<br />
<figure><img src="media/17448568756381/17449453163079.jpg" alt="" /></figure></p>
<p>MCP server 是 MCP 架构中的关键组件，它可以提供 3 种主要类型的功能：</p>
<p>○ <a href="https://modelcontextprotocol.io/docs/concepts/resources">资源（Resources）</a>：将 Server 上的数据和内容开放给大语言模型，可以是文本或二进制数据。如 API 响应、文件内容、图像等。<br />
○ <a href="https://modelcontextprotocol.io/docs/concepts/tools">工具（Tools）</a>：可以被调用的函数，这些函数可由客户端调用，并由 LLM 使用来执行操作。<br />
○ <a href="https://modelcontextprotocol.io/docs/concepts/prompts">提示（Prompts）</a>：预先编写的可复用的提示词模板和工作流程。<br />
<figure><img src="media/17448568756381/17449526186282.jpg" alt="" /></figure></p>
<p>这些功能使 MCP server 能够为 AI 应用提供丰富的上下文信息和操作能力，从而增强 LLM 的实用性和灵活性。</p>
<h3><a id="%E4%B8%80%E4%B8%AA%E5%BD%A2%E8%B1%A1%E7%9A%84%E6%AF%94%E5%96%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一个形象的比喻</h3>
<p>我在网上看到了一个比较形象的比喻，感觉还不错，摘录到这里，如果需要查看原文请点<a href="https://baijiahao.baidu.com/s?id=1829100651768604009&amp;wfr=spider&amp;for=pc">这里</a><br />
首先，用户让 LLM 调用工具，就好比我（特工少女，即 User）让男朋友（LLM）去小店（软件服务提供商）买东西（Data &amp; Tool）并使用。如果模型接到的任务则可能需要多个工具调用（Tool Use），这就好比我跟男朋友讲的需求比较复杂，比如做从零做一道番茄炒蛋。<br />
<figure><img src="media/17448568756381/17449608021782.jpg" alt="" /></figure></p>
<p>然后男朋友通过规划（Planning）决定去苏泊尔买个锅和铲，去菜场买个西红柿和鸡蛋，再去便利店买个糖和盐，以此来完成番茄炒蛋这道菜。但是在传统的 AI 应用开发过程中，男朋友（LLM）能去的小店（能使用的工具）都需要开发者预先定义线路（编写代码）。</p>
<p>但是，男朋友（LLM）每去一个新地方，都要造一条新路（编写代码），似乎不太方便。于是后来字节扣子、百度千帆、阿里云百炼等平台出现了，他们就好比是开了一个商超。商超跟各种小店说，我这里人气旺，你们直接按我们的要求来货架上架你们的商品就行，再跟我（User）说我这现成的商品多，以后让男朋友（LLM）来这买就行。<br />
<figure><img src="media/17448568756381/17449608153690.jpg" alt="" /></figure></p>
<p>小店们觉得这事不错，便遵守平台一定的上架规范，开始把他们的商品（Tool）变成了插件（Plugin），我（User）提的好多需求，男朋友（LLM）在这些平台上就能一站式满足了，选几个插件直接用就行，方便了挺多。</p>
<p>但是，Anthropic 干了一个什么事情呢？他想搞电商！</p>
<p>他跟小店们说，不同平台的插件规范不太一样，你们去各个平台上架插件也挺累的。咱们搞个新玩法，能让天下的男朋友（LLM）都很容易的用到更多商品（调用更多工具）。你们呢按照我这个标准，把你们的商品都做一个数字化的标准信息处理（即变成了 MCP Server），我们再定义一个叫电商组件的东西（即 MCP Client），你们的 MCP Server 要跟电商组件有互动，只要遵守一个开放的规则，这部分就是 MCP 协议，即 Server 和 Client 的通信协议。</p>
<p>此外，Anthropic 基于这个电商平台（Client）的理念做了一个淘宝的外壳，这个淘宝就好比没有包含 LLM 的 Claude Desktop。在这基础上，如果再加上 Claude 的模型，就相当于让“男朋友刷淘宝”，这一整体就构成了 MCP Host。<br />
<figure><img src="media/17448568756381/17449608349448.jpg" alt="" /></figure></p>
<p>MCP Server 只管提供各种工具，MCP Host 只管通过 MCP Client 获取并使用这些工具。然后淘宝上玲琅满目的商品很多，就形成了 MCP Market。</p>
<h3><a id="1-3%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.3 通信机制</h3>
<p>关于Client和Server之间的通信方式，MCP 协议支持两种主要的通信机制：基于Stdio（标准输入输出）的本地通信和基于SSE（Server-Sent Events）的远程通信。</p>
<p>这两种机制都使用 <a href="https://modelcontextprotocol.io/docs/concepts/transports">JSON-RPC 2.0</a> 格式进行消息传输，确保了通信的标准化和可扩展性。</p>
<p>**本地通信：**通过 stdio 传输数据，适用于在同一台机器上运行的客户端和服务器之间的通信。<br />
**远程通信：**利用 SSE 与 HTTP 结合，实现跨网络的实时数据传输，适用于需要访问远程资源或分布式部署的场景。</p>
<p><strong>连接过程</strong>：<br />
<figure><img src="media/17448568756381/17449459358047.jpg" alt="" /></figure></p>
<ol>
<li>客户端发送包含协议版本和功能的请求initialize</li>
<li>Server 使用其协议版本和功能进行响应</li>
<li>客户端发送通知作为确认initialized</li>
<li>正常消息交换开始</li>
</ol>
<h2><a id="%E4%BA%8C%E3%80%81mcp%E4%B8%8E%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF%E7%9A%84%E6%AF%94%E8%BE%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、MCP与其他技术的比较</h2>
<h3><a id="2-1%E4%B8%8E-function-calling%E5%AF%B9%E6%AF%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.1 与Function Calling对比</h3>
<p>Function Calling，最初是由OpenAI在2023年6月作为其API的一部分提出的，是一种函数调用机制，允许LLM通在生成内容的过程中调用外部函数或服务，从而获取更多能力。现在，很多其他大模型也借鉴了这种概念，纷纷推出了自己的function calling 。借助这个功能，可以调用外网检索引擎、天气查询、图片生成服务、音乐生成服务调用等。</p>
<table>
<thead>
<tr>
<th>对比项目</th>
<th>MCP</th>
<th>Function Calling</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>模型和其它设备集成的标准接口，包含：工具 Tools、资源 Resources、提示词 Prompts</td>
<td>将模型连接到外部数据和系统，平铺式的罗列 Tools 工具。和 MCP Tool 不同的在于：MCP Tool 的函数约定了输入输出的协议规范。</td>
</tr>
<tr>
<td>性质</td>
<td>协议</td>
<td>功能</td>
</tr>
<tr>
<td>协议</td>
<td>JSON-RPC，支持双向通信、可发现性、更新通知能力。</td>
<td>JSON-Schema，静态函数调用。</td>
</tr>
<tr>
<td>调用方式</td>
<td>Stdio / SSE / 同进程调用</td>
<td>同进程调用 / 编程语言对应的函数</td>
</tr>
<tr>
<td>范围</td>
<td>通用（多数据源、多功能）</td>
<td>特定场景（单一数据源或功能）</td>
</tr>
<tr>
<td>目标</td>
<td>统一接口，实现互操作</td>
<td>扩展模型能力</td>
</tr>
<tr>
<td>实现</td>
<td>基于标准协议</td>
<td>没有统一的标准，各个大模型提供厂商都有自己的接入方式</td>
</tr>
<tr>
<td>开发复杂度</td>
<td>低：通过统一协议实现多源兼容</td>
<td>高：需要为每个任务单独开发函数</td>
</tr>
<tr>
<td>复用性</td>
<td>高：一次开发，可多场景使用</td>
<td>低：函数通常为特定任务设计</td>
</tr>
<tr>
<td>灵活性</td>
<td>高：支持动态适配和扩展</td>
<td>低：功能扩展需要额外开发</td>
</tr>
<tr>
<td>适用场景</td>
<td>动态、复杂场景，如跨平台数据访问和整合</td>
<td>简单任务。如天气查询、翻译等</td>
</tr>
</tbody>
</table>
<p><figure><img src="media/17448568756381/1adfb43d17054bdfe566865c141baf35.png" alt="1adfb43d17054bdfe566865c141baf35" /><figcaption>1adfb43d17054bdfe566865c141baf35<figcaption></figure></p>
<p>Function calling 功能单一，不具备上下文管理能力，一次只执行一个任务，一般是同步进行调用。没有特定的标准，需要厂商或者我们自己去开发实现。生态相对封闭，没有多少开源项目，定制化比较多。<br />
MCP 功能复杂，可以支持多轮对话，一次能调用多个任务，也可以异步执行。有统一的标准，只要是适配了 MCP 的 Server 都可以用统一的代码去调用，而且除了工具调用，还提供了提示词和上下文资源。</p>
<h3><a id="2-2%E4%B8%BE%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.2 举例</h3>
<ul>
<li>
<p>如果你的 function 最初需要两个参数（例如，天气服务的 location 参数和 date 参数，用户需严格按此参数结构构建应用。<br />
<figure><img src="media/17448568756381/17449453826664.jpg" alt="" /></figure></p>
</li>
<li>
<p>之后，如果你决定为该 function 添加第三个必选参数（例如，unit参数（温度单位）），将“契约”进行变更。<br />
<figure><img src="media/17448568756381/17449454190209.jpg" alt="" /></figure></p>
</li>
<li>
<p>这意味着该 function 的所有用户都必须更新代码，增加对新参数的支持，如果未及时更新，他们的请求可能会失败、报错或提供不完整的结果。<br />
<figure><img src="media/17448568756381/17449454519373.jpg" alt="" /></figure></p>
</li>
</ul>
<p>MCP 的设计解决了这个问题，具体方法如下：</p>
<ul>
<li>
<p>MCP 引入了一种动态、灵活的方法。</p>
</li>
<li>
<p>当 Client（例如 Claude Desktop 这类 AI 应用）连接 MCP Server（例如天气服务）时，会发送初始请求，以便了解 Server 的能力。</p>
</li>
<li>
<p>Server 的响应包含可用的 tools、resources、prompts 以及相关参数的详细信息。例如，若天气 API 最初仅支持 location 和 date 参数，服务器会通过能力交换告知这些信息。<br />
<figure><img src="media/17448568756381/17449455836821.jpg" alt="" /></figure></p>
</li>
<li>
<p>当新增 unit 参数时，MCP Server 可在下次进行能力交换时动态更新能力描述。Client 无需硬编码或预定义参数，只需查询 Server 的最新能力并自动适配。<br />
<figure><img src="media/17448568756381/17449456074053.jpg" alt="" /></figure></p>
</li>
<li>
<p>这样，Client 就能使用更新后的新功能（例如在其请求中包含 unit 参数），实时调整行为，而无需重写或重新部署代码。</p>
</li>
</ul>
<p>当然，mcp协议和function call两者并不直接对立的，反而是进行相互补充：</p>
<ul>
<li>mcp协议工作在应用与外部工具对接的阶段，标准化这些工具的开发，以及在应用层接入、执行等过程，更多指的是整个让模型调用工具的整体手段。</li>
<li>function call 则工作在应用与大模型交互之间，标准化如何让大模型理解、调用外部工具。如Host 里的 LLM 向 Client 调用工具时，大多仍然使用 Function Calling。<br />
<figure><img src="media/17448568756381/17449604160957.jpg" alt="" /></figure></li>
</ul>
<h2><a id="%E4%B8%89%E3%80%81%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E4%BA%A4%E9%80%9A%E6%80%81%E5%8A%BF%E5%AE%9E%E6%97%B6%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、实战案例：交通态势实时查询</h2>
<h3><a id="3-1%E9%9C%80%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.1 需求</h3>
<p>开发一个支持自然语言查询的某市某条道路的实时交通态势，通过 MCP 调用高德 API。</p>
<h3><a id="3-2%E5%AE%9E%E7%8E%B0-mcp-server" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.2 实现MCP Server</h3>
<p>准备：高德ApiKey、安装<a href="https://github.com/modelcontextprotocol/typescript-sdk"><code>@modelcontextprotocol/sdk</code></a></p>
<p>代码如下：</p>
<pre class="line-numbers"><code class="language-ts">import { McpServer } from &quot;@modelcontextprotocol/sdk/server/mcp.js&quot;;
import { StdioServerTransport } from &quot;@modelcontextprotocol/sdk/server/stdio.js&quot;;
import { z } from &quot;zod&quot;;
// 通过命令行获取key
const API_KEY = process.argv[2];

/**
 * @description 创建服务器实例
 */
const server = new McpServer(
  {
    name: &quot;amap-traffic-mcp-server&quot;,
    version: &quot;1.0.0&quot;,
  },
  {
    capabilities: {
      resources: {},
      tools: {},
      prompts: {},
    },
    instructions: &quot;交通态势查询服务，使用高德API&quot;,
  }
);

// 注册交通态势查询工具
server.tool(
  &quot;get_traffic&quot;,
  &quot;线路交通态势查询&quot;,
  {
    city: z.string().describe(&quot;城市名称&quot;),
    name: z.string().describe(&quot;道路名，街道名字&quot;),
  },
  async ({ city, name }) =&gt; {
    try {
      // URL 编码参数
      const encodedCity = encodeURIComponent(city);
      const encodedName = encodeURIComponent(name);
      // https://lbs.amap.com/api/webservice/guide/api-advanced/traffic-situation-inquiry
      // 调用高德地图 API
      const response = await fetch(
        `https://restapi.amap.com/v3/traffic/status/road?key=${API_KEY}&amp;level=5&amp;name=${encodedName}&amp;city=${encodedCity}`
      );

      if (!response.ok) {
        throw new Error(`API请求失败: ${response.status}`);
      }

      const data = await response.json();

      // 检查 API 响应状态
      if (data.status !== &quot;1&quot;) {
        throw new Error(`高德地图API错误: ${JSON.stringify(data)}`);
      }

      // 检查是否有交通信息
      if (!data.trafficinfo) {
        return {
          content: [
            {
              type: &quot;text&quot;,
              text: `未找到 ${city} 的 ${name} 的交通信息`,
            },
          ],
        };
      }

      const { description, evaluation } = data.trafficinfo;

      // 计算道路通畅程度
      const status = evaluation?.status || &quot;未知&quot;;
      let statusText = &quot;&quot;;
      switch (status) {
        case &quot;1&quot;:
          statusText = &quot;通畅&quot;;
          break;
        case &quot;2&quot;:
          statusText = &quot;基本通畅&quot;;
          break;
        case &quot;3&quot;:
          statusText = &quot;轻度拥堵&quot;;
          break;
        case &quot;4&quot;:
          statusText = &quot;中度拥堵&quot;;
          break;
        case &quot;5&quot;:
          statusText = &quot;重度拥堵&quot;;
          break;
        default:
          statusText = &quot;未知&quot;;
      }

      return {
        content: [
          {
            type: &quot;text&quot;,
            text: `${city}${name}当前路况：${statusText}\n\n${
              description || &quot;暂无详细描述&quot;
            }`,
          },
          {
            type: &quot;text&quot;,
            text: evaluation
              ? `\n\n道路状况统计：\n- 畅通路段：${evaluation.expedite}\n- 缓行路段：${evaluation.congested}\n- 拥堵路段：${evaluation.blocked}\n- 未知路段：${evaluation.unknown}`
              : &quot;&quot;,
          },
        ],
      };
    } catch (error) {
      console.error(&quot;交通信息查询失败:&quot;, error);
      throw new Error(
        error instanceof Error ? error.message : &quot;服务调用失败，请稍后重试&quot;
      );
    }
  }
);

/**
 * @description 启动服务器
 */
async function main() {
  try {
    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.error(&quot;交通态势查询服务已启动&quot;);
  } catch (error) {
    console.error(&quot;服务启动失败:&quot;, error);
    process.exit(1);
  }
}
main();
</code></pre>
<p>在开发的时候，可以使用<a href="https://modelcontextprotocol.io/docs/tools/inspector">@modelcontextprotocol/inspector</a>进行调试。</p>
<h3><a id="3-3%E5%AE%9E%E7%8E%B0-mcp-client" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.3 实现MCP Client</h3>
<pre class="line-numbers"><code class="language-js">import { Client } from &quot;@modelcontextprotocol/sdk/client/index.js&quot;;
import { StdioClientTransport } from &quot;@modelcontextprotocol/sdk/client/stdio.js&quot;;

const transport = new StdioClientTransport({
  command: &quot;node&quot;,
  args: [&quot;/Users/bwrong/0WorkSpace/00.MyStudy/mcp-demo/server/build/index.js&quot;,'API-KEY']
});

const client = new Client(
  {
    name: &quot;traffic-client&quot;,
    version: &quot;1.0.0&quot;
  }
);

await client.connect(transport);
console.log(&quot;connect success&quot;);
// List prompts
// const prompts = await client.listPrompts();

// Get a prompt
// const prompt = await client.getPrompt({
//   name: &quot;example-prompt&quot;,
//   arguments: {
//     arg1: &quot;value&quot;
//   }
// });

// List resources
// const resources = await client.listResources();

// Read a resource
// const resource = await client.readResource({
//   uri: &quot;file:///example.txt&quot;
// });
const tools = await client.listTools();
console.log(tools);
// Call a tool
const result = await client.callTool({
  name: &quot;get_traffic&quot;,
  arguments: {
    city: &quot;成都市&quot;,
    name: &quot;天府大道北段&quot;
  }
});

console.log(result);
</code></pre>
<p>在Client中可以连接Server，然后获取它提供的resource、prompt、tools，并可以执行调用。</p>
<p>当然我们也可以使用现有的一些支持MCP集成的应用来调用，不同的应用支持的功能可能有差异，具体可查看<a href="https://modelcontextprotocol.io/clients">这里</a>。下面我们使用cursor来演示。</p>
<ol>
<li>打开cursor的MCP配置文件。</li>
<li>添加配置</li>
</ol>
<pre class="line-numbers"><code class="language-js">{
  &quot;mcpServers&quot;: {
    &quot;amap-traffic-mcp-server&quot;: {
      &quot;type&quot;: &quot;stdio&quot;,
      &quot;command&quot;: &quot;node&quot;,
      &quot;args&quot;: [
        &quot;/Users/bwrong/0WorkSpace/00.MyStudy/mcp-demo/server/build/index.js&quot;,
        &quot;111111111111111111&quot; // 你的高德API-key
      ]
    }
  }
}
</code></pre>
<ol start="3">
<li>正常情况可以看到mcp列表中已出现添加的MCP及它提供的tools<br />
<figure><img src="media/17448568756381/17449489596763.jpg" alt="" /></figure></li>
<li>在chart面板中输入“帮我查询成都市天府大道北段道路交通情况&quot;。可以看到它调用了MCP，并返回了结果<br />
<figure><img src="media/17448568756381/17449490810948.jpg" alt="" /></figure><br />
当然，如果你的MCP想共享给别人使用，那么可以发布到npm上，在<code>package.json</code>中添加如下内容,支持使用npx运行。</li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">&quot;bin&quot;: {
    &quot;amap-traffic-mcp-server&quot;: &quot;./build/index.js&quot;
}
</code></pre>
<p>然后进行发布，发布后，别人就可以使用如下方式进行集成了。</p>
<pre class="line-numbers"><code class="language-plain_text">&quot;amap-traffic-mcp-server&quot;: {
  &quot;type&quot;: &quot;stdio&quot;,
  &quot;command&quot;: &quot;npx&quot;,
  &quot;args&quot;: [
    &quot;amap-traffic-mcp-server&quot;,
    &quot;cc2b744799eaa97ade23c468e272c731&quot;
  ]
}
</code></pre>
<p>更多代码亲查看<a href="https://github.com/BWrong/mcp-demo">这里</a></p>
<h2><a id="%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8%E7%A4%BE%E5%8C%BA%E7%8E%B0%E6%9C%89%E7%9A%84mcp%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、使用社区现有的MCP服务</h2>
<p>MCP的出现，极大降低了大模型调用外部海量工具、软件、接口的门槛，越来越多的软件及工具厂商参与到 MCP 服务（MCP Server）生态的建设中，将其产品能力包装为 MCP 服务开放给 AI 模型使用。以下是一些MCP托管平台：</p>
<ul>
<li><a href="https://www.modelscope.cn/mcp?page=1">魔搭</a></li>
<li><a href="https://glama.ai/mcp/servers">Glama</a></li>
<li><a href="https://smithery.ai/">Smithery</a></li>
<li><a href="https://mcp.composio.dev/">Composio</a></li>
</ul>
<p>一些有意思的MCP Server:</p>
<ul>
<li><a href="https://www.modelscope.cn/mcp/servers/@modelcontextprotocol/fetch">Fetch网页内容抓取</a></li>
<li><a href="https://www.modelscope.cn/mcp/servers/@modelcontextprotocol/github">GitHub</a></li>
<li><a href="https://www.modelscope.cn/mcp/servers/@GLips/Figma-Context-MCP">Figma</a></li>
<li><a href="https://www.modelscope.cn/mcp/servers/@21st-dev/magic-mcp">magic</a></li>
<li><a href="https://www.modelscope.cn/mcp/servers/@ahujasid/blender-mcp">Blender</a></li>
</ul>
<p>参考文档：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/27327515233">一文看懂：MCP(大模型上下文协议)</a></li>
<li><a href="https://blog.csdn.net/qq_45066628/article/details/146225428">一文带你入门 MCP（模型上下文协议）</a></li>
<li><a href="https://blog.dailydoseofds.com/p/visual-guide-to-model-context-protocol">Visual Guide to Model Context Protocol (MCP)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[傻傻分不清之 Cookie、Session、Token、JWT]]></title>
    <link href="https://www.bwrong.cn/17289745203360.html"/>
    <updated>2024-10-15T14:42:00+08:00</updated>
    <id>https://www.bwrong.cn/17289745203360.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6844904034181070861?searchId=20241015143446C1B857F324CEF98D5DDE#heading-22">juejin.cn</a></p>
</blockquote>
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A4%E8%AF%81%EF%BC%88authentication%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是认证（Authentication）</h2>
<ul>
<li>通俗地讲就是<strong>验证当前用户的身份</strong>，证明 “你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）</li>
<li>互联网中的认证：
<ul>
<li>用户名密码登录</li>
<li>邮箱发送登录链接</li>
<li>手机号接收验证码</li>
<li>只要你能收到邮箱 / 验证码，就默认你是账号的主人</li>
</ul>
</li>
</ul>
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%88%E6%9D%83%EF%BC%88authorization%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是授权（Authorization）</h2>
<ul>
<li><strong>用户授予第三方应用访问该用户某些资源的权限</strong>
<ul>
<li>你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）</li>
<li>你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）</li>
</ul>
</li>
<li>实现授权的方式有：cookie、session、token、OAuth</li>
</ul>
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%AD%E8%AF%81%EF%BC%88credentials%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是凭证（Credentials）</h2>
<ul>
<li><strong>实现认证和授权的前提</strong>是需要一种<strong>媒介（证书）</strong> 来标记访问者的身份
<ul>
<li>在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。</li>
<li>在现实生活中，每个人都会有一张专属的<a href="https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E5%25B1%2585%25E6%25B0%2591%25E8%25BA%25AB%25E4%25BB%25BD%25E8%25AF%2581%2F2080960" title="https://baike.baidu.com/item/%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81/2080960">居民身份证</a>，是用于证明持有人身份的一种法定<a href="https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E8%25AF%2581%25E4%25BB%25B6%2F5804999" title="https://baike.baidu.com/item/%E8%AF%81%E4%BB%B6/5804999">证件</a>。通过身份证，我们可以办理手机卡 / 银行卡 / 个人贷款 / 交通出行等等，这就是<strong>认证的凭证。</strong></li>
<li>在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞 / 收藏 / 分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。</li>
</ul>
</li>
</ul>
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AFcookie" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是 Cookie</h2>
<ul>
<li><strong>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息</strong>）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</li>
<li><strong>cookie 存储在客户端：</strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li>
<li><strong>cookie 是不可跨域的：</strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，<strong>一级域名和二级域名之间是允许共享使用的</strong>（<strong>靠的是 domain）</strong>。</li>
</ul>
<p><strong>cookie 重要的属性</strong></p>
<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>name=value</strong></td><td>键值对，设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong><br>- 如果值为 Unicode 字符，需要为字符编码。<br>- 如果值为二进制数据，则需要使用 BASE64 编码。<br></td></tr><tr><td><strong>domain</strong></td><td>指定 cookie 所属域名，默认是当前域名</td></tr><tr><td><strong>path</strong></td><td><strong>指定 cookie 在哪个路径（路由）下生效，默认是 '/'</strong>。<br>如果设置为 <code>/abc</code>，则只有 <code>/abc</code> 下的路由可以访问到该 cookie，如：<code>/abc/read</code>。</td></tr><tr><td><strong>maxAge</strong></td><td>cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。<br>- <strong>比 expires 好用</strong>。<br></td></tr><tr><td><strong>expires</strong></td><td>过期时间，在设置的某个时间点后该 cookie 就会失效。<br>一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除</td></tr><tr><td><strong>secure</strong></td><td>该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。<br>当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</td></tr><tr><td><strong>httpOnly</strong></td><td><strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></td></tr><tr><td></td><td></td></tr></tbody></table>
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AFsession" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是 Session</h2>
<ul>
<li><strong>session 是另一种记录服务器和客户端会话状态的机制</strong></li>
<li><strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中</strong></li>
</ul>
<p><figure><img src="media/17289745203360/17289745622104.png" alt="" /></figure></p>
<ul>
<li><strong>session 认证流程：</strong>
<ul>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li>
<li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li>
<li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li>
</ul>
</li>
</ul>
<p>根据以上流程可知，<strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登录状态。</p>
<h2><a id="cookie%E5%92%8C-session%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cookie 和 Session 的区别</h2>
<ul>
<li><strong>安全性：</strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li>
<li><strong>存取值的类型不同</strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li>
<li><strong>有效期不同：</strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li>
<li><strong>存储大小不同：</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li>
</ul>
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AFtoken%EF%BC%88%E4%BB%A4%E7%89%8C%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是 Token（令牌）</h2>
<h3><a id="acesss-token" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Acesss Token</h3>
<ul>
<li><strong>访问资源接口（API）时所需要的资源凭证</strong></li>
<li><strong>简单 token 的组成：</strong> uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li>
<li><strong>特点：</strong>
<ul>
<li><strong>服务端无状态化、可扩展性好</strong></li>
<li><strong>支持移动端设备</strong></li>
<li>安全</li>
<li>支持跨程序调用</li>
</ul>
</li>
<li><strong>token 的身份验证流程：</strong></li>
</ul>
<p><figure><img src="media/17289745203360/17289745622140.png" alt="" /></figure></p>
<ol>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li>
<li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</li>
</ol>
<ul>
<li><strong>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</strong></li>
<li><strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</strong></li>
<li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li>
</ul>
<h3><a id="refresh-token" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Refresh Token</h3>
<ul>
<li>
<p>另外一种 token——refresh token</p>
</li>
<li>
<p>refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</p>
</li>
</ul>
<p><figure><img src="media/17289745203360/17289745622163.png" alt="" /></figure></p>
<ul>
<li>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。</li>
<li>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。</li>
</ul>
<h2><a id="token%E5%92%8C-session%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Token 和 Session 的区别</h2>
<ul>
<li>Session 是一种<strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息</strong>。而 Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></li>
<li>Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。<strong>如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</strong></li>
<li>所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App 上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：<strong>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。</strong></li>
</ul>
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AFjwt" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是 JWT</h2>
<ul>
<li>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。</li>
<li>是一种<strong>认证授权机制</strong>。</li>
<li>JWT 是为了在网络应用环境间<strong>传递声明</strong>而执行的一种基于 JSON 的开放标准（<a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc7519" title="https://tools.ietf.org/html/rfc7519">RFC 7519</a>）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</li>
<li>可以使用 HMAC 算法或者是 RSA 的公 / 私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</li>
<li><strong>阮一峰老师的 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2018%2F07%2Fjson_web_token-tutorial.html" title="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JSON Web Token 入门教程</a> 讲的非常通俗易懂，这里就不再班门弄斧了</strong></li>
</ul>
<h3><a id="%E7%94%9F%E6%88%90jwt" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生成 JWT</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fjwt.io%2F" title="https://jwt.io/">jwt.io/</a><br />
<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jsonwebtoken.io%2F" title="https://www.jsonwebtoken.io/">www.jsonwebtoken.io/</a></p>
<h3><a id="jwt%E7%9A%84%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JWT 的原理</h3>
<p><figure><img src="media/17289745203360/17289745622175.png" alt="" /></figure></p>
<ul>
<li><strong>JWT 认证流程：</strong>
<ul>
<li>用户输入用户名 / 密码登录，服务端认证成功后，会返回给客户端一个 JWT</li>
<li>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</li>
<li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用 Bearer 模式添加 JWT，其内容看起来是下面这样</li>
</ul>
</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">Authorization: Bearer &lt;token&gt;


</code></pre>
<ul>
<li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</li>
<li>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</li>
<li>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li>
<li>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</li>
</ul>
<h3><a id="jwt%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JWT 的使用方式</h3>
<ul>
<li>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</li>
</ul>
<h4><a id="%E6%96%B9%E5%BC%8F%E4%B8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方式一</h4>
<ul>
<li>
<p>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。</p>
<pre class="line-numbers"><code class="language-plain_text">GET /calendar/v1/events
Host: api.example.com
Authorization: Bearer &lt;token&gt;


</code></pre>
<ul>
<li>用户的状态不会存储在服务端的内存中，这是一种 <strong>无状态的认证机制</strong></li>
<li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。</li>
<li>由于 JWT 是自包含的，因此减少了需要查询数据库的需要</li>
<li>JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。</li>
<li>因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而<strong>不需要担心跨域资源共享问题</strong>（CORS）</li>
</ul>
</li>
</ul>
<h4><a id="%E6%96%B9%E5%BC%8F%E4%BA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方式二</h4>
<ul>
<li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。</li>
</ul>
<h4><a id="%E6%96%B9%E5%BC%8F%E4%B8%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方式三</h4>
<ul>
<li>通过 URL 传输</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">http://www.example.com/user?token=xxx


</code></pre>
<h3><a id="%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8jwt" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目中使用 JWT</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyjdjiayou%2Fjwt-demo" title="https://github.com/yjdjiayou/jwt-demo"><strong>项目地址</strong></a></p>
<p>Token 和 JWT 的区别</p>
<hr />
<p><strong>相同：</strong></p>
<ul>
<li>都是访问资源的令牌</li>
<li>都可以记录用户的信息</li>
<li>都是使服务端无状态化</li>
<li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li>
<li>JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li>
</ul>
<p>常见的前后端鉴权方式</p>
<hr />
<ol>
<li>Session-Cookie</li>
<li>Token 验证（包括 JWT，SSO）</li>
<li>OAuth2.0（开放授权）</li>
</ol>
<h2><a id="%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常见的加密算法</h2>
<p><figure><img src="media/17289745203360/17289745622186.png" alt="" /></figure></p>
<ul>
<li>哈希算法 (Hash Algorithm) 又称散列算法、散列函数、哈希函数，是一种从任何一种数据中创建小的数字 “指纹” 的方法。哈希算法将数据重新打乱混合，重新创建一个哈希值。</li>
<li>哈希算法主要用来保障数据真实性 (即完整性)，即发信人将原始消息和哈希值一起发送，收信人通过相同的哈希函数来校验原始数据是否真实。</li>
<li>哈希算法通常有以下几个特点：
<ul>
<li>正像快速：原始数据可以快速计算出哈希值</li>
<li>逆向困难：通过哈希值基本不可能推导出原始数据</li>
<li>输入敏感：原始数据只要有一点变动，得到的哈希值差别很大</li>
<li>冲突避免：很难找到不同的原始数据得到相同的哈希值，宇宙中原子数大约在 10 的 60 次方到 80 次方之间，所以 2 的 256 次方有足够的空间容纳所有的可能，算法好的情况下冲突碰撞的概率很低：
<ul>
<li>2 的 128 次方为 340282366920938463463374607431768211456，也就是 10 的 39 次方级别</li>
<li>2 的 160 次方为 1.4615016373309029182036848327163e+48，也就是 10 的 48 次方级别</li>
<li>2 的 256 次方为 1.1579208923731619542357098500869 × 10 的 77 次方，也就是 10 的 77 次方</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>以上不能保证数据被恶意篡改，原始数据和哈希值都可能被恶意篡改，要保证不被篡改，可以使用 RSA 公钥私钥方案，再配合哈希值。</li>
<li>哈希算法主要用来防止计算机传输过程中的错误，早期计算机通过前 7 位数据第 8 位奇偶校验码来保障（12.5% 的浪费效率低），对于一段数据或文件，通过哈希算法生成 128bit 或者 256bit 的哈希值，如果校验有问题就要求重传。</li>
</ol>
<h2><a id="%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常见问题</h2>
<h3><a id="%E4%BD%BF%E7%94%A8cookie%E6%97%B6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 cookie 时需要考虑的问题</h3>
<ul>
<li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性</li>
<li>不要存储敏感数据，比如用户密码，账户余额</li>
<li>使用 httpOnly 在一定程度上提高安全性</li>
<li>尽量减少 cookie 的体积，能存储的数据量不能超过 4kb</li>
<li>设置正确的 domain 和 path，减少数据传输</li>
<li><strong>cookie 无法跨域</strong></li>
<li>一个浏览器针对一个网站最多存 20 个 Cookie，浏览器一般只允许存放 300 个 Cookie</li>
<li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li>
</ul>
<h3><a id="%E4%BD%BF%E7%94%A8session%E6%97%B6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 session 时需要考虑的问题</h3>
<ul>
<li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</li>
<li>当网站采用<strong>集群部署</strong>的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。</li>
<li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li>
<li><strong>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？</strong> 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</li>
<li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li>
</ul>
<h3><a id="%E4%BD%BF%E7%94%A8token%E6%97%B6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 token 时需要考虑的问题</h3>
<ul>
<li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。</li>
<li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li>
<li><strong>token 可以避免 CSRF 攻击 (因为不需要 cookie 了)</strong></li>
<li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li>
</ul>
<h3><a id="%E4%BD%BF%E7%94%A8jwt%E6%97%B6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 JWT 时需要考虑的问题</h3>
<ul>
<li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li>
<li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li>
<li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li>
<li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li>
<li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li>
<li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li>
<li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li>
<li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li>
</ul>
<h3><a id="%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%97%B6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用加密算法时需要考虑的问题</h3>
<ul>
<li>绝不要以<strong>明文存储</strong>密码</li>
<li><strong>永远使用 哈希算法 来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码</strong>。编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法， 但是编码就存在解码，加密就存在解密。</li>
<li>绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用强密码哈希算法。</li>
<li>绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 <strong>一次性的</strong>（这点很重要）密码，然后把这个密码发送给用户。</li>
</ul>
<h3><a id="%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B8%8Bsession%E5%85%B1%E4%BA%AB%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分布式架构下 session 共享方案</h3>
<h4><a id="1-session%E5%A4%8D%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. session 复制</h4>
<ul>
<li>任何一个服务器上的 session 发生改变（增删改），该节点会把这个 session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 session ，以此来保证 session 同步</li>
</ul>
<p><strong>优点：</strong> 可容错，各个服务器间 session 能够实时响应。<br />
<strong>缺点：</strong> 会对网络负荷造成一定压力，如果 session 量大的话可能会造成网络堵塞，拖慢服务器性能。</p>
<h4><a id="2%E7%B2%98%E6%80%A7-session-ip%E7%BB%91%E5%AE%9A%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 粘性 session /IP 绑定策略</h4>
<ul>
<li><strong>采用 Ngnix 中的 ip_hash 机制，将某个 ip 的所有请求都定向到同一台服务器上，即将用户与服务器绑定。</strong> 用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 session 的话，那么用户以后的每次请求都会转发到 A 服务器上，相当于把用户和 A 服务器粘到了一块，这就是粘性 session 机制。</li>
</ul>
<p><strong>优点：</strong> 简单，不需要对 session 做任何处理。<br />
<strong>缺点：</strong> 缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的 session 信息都将失效。<br />
<strong>适用场景：</strong> 发生故障对客户产生的影响较小；服务器发生故障是低概率事件 。<br />
<strong>实现方式：</strong> 以 Nginx 为例，在 upstream 模块配置 ip_hash 属性即可实现粘性 session。</p>
<h4><a id="3-session%E5%85%B1%E4%BA%AB%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. session 共享（常用）</h4>
<ul>
<li>使用分布式缓存方案比如 Memcached 、Redis 来缓存 session，但是要求 Memcached 或 Redis 必须是集群</li>
<li>把 session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：
<ul>
<li>实现了 session 共享；</li>
<li>可以水平扩展（增加 Redis 服务器）；</li>
<li>服务器重启 session 不丢失（不过也要注意 session 在 Redis 中的刷新 / 失效机制）；</li>
<li>不仅可以跨服务器 session 共享，甚至可以跨平台（例如网页端和 APP 端）</li>
</ul>
</li>
</ul>
<p><figure><img src="media/17289745203360/17289745622205.png" alt="" /></figure></p>
<h4><a id="4-session%E6%8C%81%E4%B9%85%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. session 持久化</h4>
<ul>
<li>将 session 存储到数据库中，保证 session 的持久化</li>
</ul>
<p><strong>优点：</strong> 服务器出现问题，session 不会丢失<br />
<strong>缺点：</strong> 如果网站的访问量很大，把 session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p>
<h3><a id="%E5%8F%AA%E8%A6%81%E5%85%B3%E9%97%AD%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%8Csession%E7%9C%9F%E7%9A%84%E5%B0%B1%E6%B6%88%E5%A4%B1%E4%BA%86%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>只要关闭浏览器 ，session 真的就消失了？</strong></h3>
<p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。<br />
然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。<br />
恰恰是<strong>由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</strong></p>
<h2><a id="%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目地址</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyjdjiayou%2Fjwt-demo" title="https://github.com/yjdjiayou/jwt-demo"><strong>在项目中使用 JWT</strong></a></p>
<h2><a id="%E5%90%8E%E8%AF%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>后语</h2>
<ul>
<li>本文只是基于自己的理解讲了理论知识，因为对后端 / 算法知识不是很熟，如有谬误，还请告知，万分感谢</li>
<li>如果本文对你有所帮助，还请点个赞~~</li>
</ul>
<h2><a id="%E5%8F%82%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2Fcookie%2F1119%3Ffr%3Daladdin" title="https://baike.baidu.com/item/cookie/1119?fr=aladdin"><strong>百度百科 - cookie</strong></a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2Fsession%2F479100%3Ffr%3Daladdin%233" title="https://baike.baidu.com/item/session/479100?fr=aladdin#3"><strong>百度百科 - session</strong></a></p>
<p><a href="https://juejin.cn/post/6844903864810864647" title="https://juejin.cn/post/6844903864810864647"><strong>详解 Cookie，Session，Token</strong></a></p>
<p><a href="https://juejin.cn/post/6844904009061367821#heading-0" title="https://juejin.cn/post/6844904009061367821#heading-0"><strong>一文彻底搞懂 Cookie、Session、Token 到底是什么</strong></a></p>
<p><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Flyzg%2Fp%2F6067766.html" title="https://www.cnblogs.com/lyzg/p/6067766.html">3 种 web 会话管理的方式</a>！！！</strong></p>
<p><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2FJamesWang1993%2Fp%2F8593494.html" title="https://www.cnblogs.com/JamesWang1993/p/8593494.html">Token ，Cookie 和 Session 的区别</a>！！！</strong></p>
<p><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fmoyand%2Fp%2F9047978.html" title="https://www.cnblogs.com/moyand/p/9047978.html">彻底理解 cookie、session、token</a>！！！</strong></p>
<p><a href="https://juejin.cn/post/6844903781704941576" title="https://juejin.cn/post/6844903781704941576"><strong>前端鉴权</strong></a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FSHA-1" title="https://zh.wikipedia.org/wiki/SHA-1"><strong>SHA-1</strong></a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FSHA-2" title="https://zh.wikipedia.org/wiki/SHA-2"><strong>SHA-2</strong></a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FSHA-3" title="https://zh.wikipedia.org/wiki/SHA-3"><strong>SHA-3</strong></a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fzhezhebie%2Farticle%2Fdetails%2F71631077" title="https://blog.csdn.net/zhezhebie/article/details/71631077"><strong>不要再使用 MD5 和 SHA1 加密密码了！</strong></a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.liaoxuefeng.com%2Fwiki%2F1022910821149312%2F1023025778520640" title="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025778520640"><strong>廖雪峰 Node 教程之 crypto</strong></a><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.liaoxuefeng.com%2Fwiki%2F1022910821149312%2F1023025778520640" title="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025778520640"></a></p>
<h2><a id="%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>推荐阅读</h2>
<p><a href="https://juejin.cn/post/6844904021233238024" title="https://juejin.cn/post/6844904021233238024"><strong>你真的了解 React 生命周期吗</strong></a></p>
<p><strong><a href="https://juejin.cn/post/6844903985338400782" title="https://juejin.cn/post/6844903985338400782">React Hooks 详解 【近 1W 字】+ 项目实战</a></strong></p>
<p><strong><a href="https://juejin.cn/post/6844904017487724557" title="https://juejin.cn/post/6844904017487724557">React SSR 详解【近 1W 字】+ 2 个项目实战</a></strong></p>
<p><strong><a href="https://juejin.cn/post/6844903966849892359" title="https://juejin.cn/post/6844903966849892359">从 0 到 1 实现一款简易版 Webpack</a></strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《JavaScript框架设计（第2版)》_司徒正美]]></title>
    <link href="https://www.bwrong.cn/17280550301242.html"/>
    <updated>2024-10-04T23:17:10+08:00</updated>
    <id>https://www.bwrong.cn/17280550301242.html</id>
    <content type="html"><![CDATA[
<blockquote>
<ul>
<li><figure><img src="https://res.weread.qq.com/wrepub/CB_EVOAi2AgV6Ep6db6cNE4q5U8_parsecover" alt=" 《JavaScript框架设计（第2版)》_司徒正美|200" /><figcaption> 《JavaScript框架设计（第2版)》_司徒正美|200<figcaption></figure></li>
<li>书名： 《JavaScript框架设计（第2版)》_司徒正美</li>
<li>作者： 司徒正美</li>
<li>简介：</li>
<li>出版时间</li>
<li>ISBN：</li>
<li>分类：</li>
<li>出版社： 人民邮电出版社</li>
</ul>
</blockquote>
<h1><a id="%E9%AB%98%E4%BA%AE%E5%88%92%E7%BA%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高亮划线</h1>
<h2><a id="%E7%89%88%E6%9D%83%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>版权信息</h2>
<h2><a id="%E5%86%85%E5%AE%B9%E6%8F%90%E8%A6%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内容提要</h2>
<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<h2><a id="infoq%E8%AE%BF%E8%B0%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>InfoQ访谈</h2>
<h2><a id="%E7%AC%AC1%E7%AB%A0%E7%A7%8D%E5%AD%90%E6%A8%A1%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第1章 种子模块</h2>
<h2><a id="%E7%AC%AC2%E7%AB%A0%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第2章 语言模块</h2>
<ul>
<li>📌 大数相加出问题是由于精度的不足，小数相加出问题是进制转算时产生误差。 ^CB-BOt3Xf3Y99Xw6kW6ke0YgDkj-6-47684-47718
<ul>
<li>⏱ 2023-12-20 08:25:18</li>
</ul>
</li>
</ul>
<h2><a id="%E7%AC%AC3%E7%AB%A0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%97%85%E6%8E%A2%E4%B8%8E%E7%89%B9%E5%BE%81%E4%BE%A6%E6%B5%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第3章 浏览器嗅探与特征侦测</h2>
<h2><a id="%E7%AC%AC4%E7%AB%A0%E7%B1%BB%E5%B7%A5%E5%8E%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第4章 类工厂</h2>
<h2><a id="%E7%AC%AC5%E7%AB%A0%E9%80%89%E6%8B%A9%E5%99%A8%E5%BC%95%E6%93%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第5章 选择器引擎</h2>
<h2><a id="%E7%AC%AC6%E7%AB%A0%E8%8A%82%E7%82%B9%E6%A8%A1%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第6章 节点模块</h2>
<h2><a id="%E7%AC%AC7%E7%AB%A0%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第7章 数据缓存模块</h2>
<h2><a id="%E7%AC%AC8%E7%AB%A0%E6%A0%B7%E5%BC%8F%E6%A8%A1%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第8章 样式模块</h2>
<h2><a id="%E7%AC%AC9%E7%AB%A0%E5%B1%9E%E6%80%A7%E6%A8%A1%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第9章 属性模块</h2>
<h2><a id="%E7%AC%AC10%E7%AB%A0-pc%E7%AB%AF%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第10章 PC端的事件系统</h2>
<h2><a id="%E7%AC%AC11%E7%AB%A0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第11章 移动端的事件系统</h2>
<h2><a id="%E7%AC%AC12%E7%AB%A0%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第12章 异步模型</h2>
<h2><a id="%E7%AC%AC13%E7%AB%A0%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第13章 数据交互模块</h2>
<h2><a id="%E7%AC%AC14%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第14章 动画引擎</h2>
<h2><a id="%E7%AC%AC15%E7%AB%A0mvvm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第15章MVVM</h2>
<h2><a id="%E7%AC%AC16%E7%AB%A0%E7%BB%84%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第16章 组件</h2>
<h2><a id="%E5%BD%A9%E8%9B%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>彩蛋</h2>
<h2><a id="%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E5%BC%82%E6%AD%A5%E7%A4%BE%E5%8C%BA%EF%BC%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>欢迎来到异步社区！</h2>
<h1><a id="%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>读书笔记</h1>
<h1><a id="%E6%9C%AC%E4%B9%A6%E8%AF%84%E8%AE%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>本书评论</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vue.js设计与实现]]></title>
    <link href="https://www.bwrong.cn/17280550301256.html"/>
    <updated>2024-10-04T23:17:10+08:00</updated>
    <id>https://www.bwrong.cn/17280550301256.html</id>
    <content type="html"><![CDATA[
<blockquote>
<ul>
<li><figure><img src="https://cdn.weread.qq.com/weread/cover/96/cpPlatform_kmqPY1boCDVyMxq2AvPdCY/t7_cpPlatform_kmqPY1boCDVyMxq2AvPdCY.jpg" alt=" Vue.js设计与实现|200" /><figcaption> Vue.js设计与实现|200<figcaption></figure></li>
<li>书名： Vue.js设计与实现</li>
<li>作者： 霍春阳　著</li>
<li>简介： 本书基于Vue.js 3，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解Vue.js中各个功能模块的实现，细致剖析框架设计原理。全书共18章，分为六篇，主要内容包括：框架设计概览、响应系统、渲染器、组件化、编译器和服务端渲染等。通过阅读本书，对Vue.js 2/3具有上手经验的开发人员能够进一步理解Vue.js框架的实现细节，没有Vue.js使用经验但对框架设计感兴趣的前端开发人员，能够快速掌握Vue.js的设计原理。</li>
<li>出版时间 2022-01-01 00:00:00</li>
<li>ISBN： 9787115583864</li>
<li>分类： 计算机-软件学习</li>
<li>出版社： 人民邮电出版社</li>
</ul>
</blockquote>
<h1><a id="%E9%AB%98%E4%BA%AE%E5%88%92%E7%BA%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高亮划线</h1>
<h2><a id="%E7%AC%AC1%E7%AB%A0%E6%9D%83%E8%A1%A1%E7%9A%84%E8%89%BA%E6%9C%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第1章 权衡的艺术</h2>
<ul>
<li>
<p>📌 声明式代码的性能不优于命令式代码的性能。 ^3300028078-6-3568-3595</p>
<ul>
<li>⏱ 2023-09-19 08:17:49</li>
</ul>
</li>
<li>
<p>📌 声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗 ^3300028078-6-4294-4337</p>
<ul>
<li>⏱ 2023-10-07 10:16:55</li>
</ul>
</li>
<li>
<p>📌 命令式更加关注过程，而声明式更加关注结果。 ^3300028078-6-13314-13335</p>
<ul>
<li>⏱ 2023-10-07 10:19:54</li>
</ul>
</li>
<li>
<p>📌 命令式在理论上可以做到极致优化，但是用户要承受巨大的心智负担；而声明式能够有效减轻用户的心智负担，但是性能上有一定的牺牲， ^3300028078-6-13335-13396</p>
<ul>
<li>⏱ 2023-10-07 10:20:22</li>
</ul>
</li>
</ul>
<h2><a id="%E7%AC%AC2%E7%AB%A0%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第2章 框架设计的核心要素</h2>
<ul>
<li>📌 想要实现 Tree-Shaking，必须满足一个条件，即模块必须是 ESM（ES Module），因为 Tree-Shaking 依赖 ESM 的静态结构 ^3300028078-7-5789-5866
<ul>
<li>⏱ 2023-10-07 10:25:10</li>
</ul>
</li>
</ul>
<h2><a id="%E7%AC%AC3%E7%AB%A0-vue-js-3%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第3章 Vue.js 3 的设计思路</h2>
<ul>
<li>
<p>📌 JavaScript 对象来描述真实的 DOM 结构 ^3300028078-8-3992-4018</p>
<ul>
<li>⏱ 2023-11-04 22:35:22</li>
</ul>
</li>
<li>
<p>📌 渲染器的作用就是把虚拟 DOM 渲染为真实 DOM ^3300028078-8-4102-4127</p>
<ul>
<li>⏱ 2023-10-07 11:56:51</li>
</ul>
</li>
<li>
<p>📌 虚拟 DOM ^3300028078-8-7864-7870</p>
<ul>
<li>⏱ 2023-11-04 22:41:07</li>
</ul>
</li>
<li>
<p>📌 其实就是用来描述真实 DOM 的普通 JavaScript 对象，渲染器会把这个对象渲染为真实 DOM 元素 ^3300028078-8-7871-7925</p>
<ul>
<li>⏱ 2023-11-04 22:41:21</li>
</ul>
</li>
<li>
<p>📌 组件就是一组 DOM 元素的封装 ^3300028078-8-8165-8188</p>
<ul>
<li>⏱ 2023-11-04 22:42:16</li>
</ul>
</li>
<li>
<p>📌 组件的实现依赖于渲染器，模板的编译依赖于编译器 ^3300028078-8-13650-13725</p>
<ul>
<li>⏱ 2023-11-04 22:46:34</li>
</ul>
</li>
</ul>
<h2><a id="%E7%AC%AC4%E7%AB%A0%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第4章 响应系统的作用与实现</h2>
<ul>
<li>
<p>📌 WeakMap 经常用于存储那些只有当 key 所引用的对象存在时（没有被回收）才有价值的信息 ^3300028078-10-11840-11887</p>
<ul>
<li>⏱ 2023-11-04 23:08:49</li>
</ul>
</li>
<li>
<p>📌 至此，我们的响应系统已经可以避免副作用函数产生遗留了。但如果你尝试运行代码，会发现目前的实现会导致无限循环执行，问题出在 trigger 函数中：01 function trigger(target, key) { 02   const depsMap = bucket.get(target) 03   if (!depsMap) return 04   const effects = depsMap.get(key) 05   effects &amp;&amp; effects.forEach(fn =&gt; fn()) // 问题出在这句代码 06 }在 trigger 函数内部，我们遍历 effects 集合，它是一个 Set 集合，里面存储着副作用函数。当副作用函数执行时，会调用 cleanup 进行清除，实际上就是从 effects 集合中将当前执行的副作用函数剔除，但是副作用函数的执行会导致其重新被收集到集合中，而此时对于 effects 集合的遍历仍在进行。这个行为可以用如下简短的代码来表达：01 const set = new Set([1]) 02 03 set.forEach(item =&gt; { 04   set.delete(1) 05   set.add(1) 06   console.log('遍历中') 07 })在上面这段代码中，我们创建了一个集合 set，它里面有一个元素数字 1，接着我们调用 forEach 遍历该集合。 ^3300028078-10-18769</p>
<ul>
<li>⏱ 2023-10-07 22:22:59</li>
</ul>
</li>
<li>
<p>📌 在调用 forEach 遍历 Set 集合时，如果一个值已经被访问过了，但该值被删除并重新添加到集合，如果此时 forEach 遍历没有结束，那么该值会重新被访问。因此，上面的代码会无限执行。解决办法很简单，我们可以构造另外一个 Set 集合并遍历它 ^3300028078-10-19644-19769</p>
<ul>
<li>⏱ 2023-10-07 22:25:05</li>
</ul>
</li>
<li>
<p>📌 可调度性是响应系统非常重要的特性 ^3300028078-10-27303-27319</p>
<ul>
<li>⏱ 2023-11-05 17:53:46</li>
</ul>
</li>
<li>
<p>📌 所谓可调度，指的是当 trigger 动作触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数以及方式。 ^3300028078-10-27336-27393</p>
<ul>
<li>⏱ 2023-11-05 17:53:46</li>
</ul>
</li>
</ul>
<h1><a id="%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>读书笔记</h1>
<h1><a id="%E6%9C%AC%E4%B9%A6%E8%AF%84%E8%AE%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>本书评论</h1>
<h2><a id="%E4%B9%A6%E8%AF%84no-1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>书评 No.1</h2>
<p>^30631064-7LN9vCCJN<br />
⏱ 2023-10-07 22:22:29</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前端架构：从入门到微前端]]></title>
    <link href="https://www.bwrong.cn/17280550301271.html"/>
    <updated>2024-10-04T23:17:10+08:00</updated>
    <id>https://www.bwrong.cn/17280550301271.html</id>
    <content type="html"><![CDATA[
<blockquote>
<ul>
<li><figure><img src="https://res.weread.qq.com/wrepub/CB_CL46DC6DNCYz6dV6cc_parsecover" alt=" 前端架构：从入门到微前端|200" /><figcaption>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入浅出Node.js (图灵原创)]]></title>
    <link href="https://www.bwrong.cn/17280550301291.html"/>
    <updated>2024-10-04T23:17:10+08:00</updated>
    <id>https://www.bwrong.cn/17280550301291.html</id>
    <content type="html"><![CDATA[
<blockquote>
<ul>
<li><figure><img src="https://res.weread.qq.com/wrepub/CB_FT7C0PC2PGOx6Xr6YD_parsecover" alt=" 深入浅出Node.js (图灵原创)|200" /><figcaption>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vue.js设计与实现 (霍春阳)]]></title>
    <link href="https://www.bwrong.cn/17280550301307.html"/>
    <updated>2024-10-04T23:17:10+08:00</updated>
    <id>https://www.bwrong.cn/17280550301307.html</id>
    <content type="html"><![CDATA[
<blockquote>
<ul>
<li><figure><img src="https://res.weread.qq.com/wrepub/CB_BCR3Xb3YY2RR6dZ6cN_parsecover" alt=" Vue.js设计与实现 (霍春阳) |200" /><figcaption>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Three.js开发指南：基于WebGL和HTML5在网页上渲染3D图形和动画(原书第3版)]]></title>
    <link href="https://www.bwrong.cn/17280550301322.html"/>
    <updated>2024-10-04T23:17:10+08:00</updated>
    <id>https://www.bwrong.cn/17280550301322.html</id>
    <content type="html"><![CDATA[
<blockquote>
<ul>
<li><figure><img src="https://res.weread.qq.com/wrepub/CB_DhX9RH9PUFUv6VV6UG_parsecover" alt=" Three.js开发指南：基于WebGL和HTML5在网页上渲染3D图形和动画(原书第3版)|200" /><figcaption>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[眼界决定你的高度：任正非给创业者的人生智慧课]]></title>
    <link href="https://www.bwrong.cn/17280550301337.html"/>
    <updated>2024-10-04T23:17:10+08:00</updated>
    <id>https://www.bwrong.cn/17280550301337.html</id>
    <content type="html"><![CDATA[
<blockquote>
<ul>
<li><figure><img src="https://cdn.weread.qq.com/weread/cover/55/YueWen_31418150/t7_YueWen_31418150.jpg" alt=" 眼界决定你的高度：任正非给创业者的人生智慧课|200" /><figcaption> 眼界决定你的高度：任正非给创业者的人生智慧课|200<figcaption></figure></li>
<li>书名： 眼界决定你的高度：任正非给创业者的人生智慧课</li>
<li>作者： 戚风</li>
<li>简介： 　　《眼界决定你的高度：任正非给创业者的人生智慧课》任正非先生是华为公司的创始人，他凭借独特的眼界和智慧，在三十余年间，将华为从一家名不见经传的民营企业，发展成全球最大的通信设备商。本书分别从眼界、战略定力、创业纲领、企业价值观、奋斗精神等角度，剖析了任正非的管理思想和人生智慧，为您讲述任正非的创业哲学。</li>
<li>出版时间 2019-12-01 00:00:00</li>
<li>ISBN： 9787516824566</li>
<li>分类： 个人成长-人生哲学</li>
<li>出版社： 台海出版社</li>
</ul>
</blockquote>
<h1><a id="%E9%AB%98%E4%BA%AE%E5%88%92%E7%BA%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高亮划线</h1>
<h2><a id="%E5%8A%9B%E4%BA%89%E6%88%90%E4%B8%BA%E4%B8%80%E6%B5%81%E7%9A%84%E5%9B%BD%E9%99%85%E6%80%A7%E4%BC%81%E4%B8%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>力争成为一流的国际性企业</h2>
<ul>
<li>📌 “在战场上，军人的使命是捍卫国家主权的尊严；在市场上，企业家的使命则是捍卫企业的市场地位。而现代商战中，只有技术自立才是根本，没有自己的科研支撑体系，企业地位就是一句空话。 ^31418150-6-1181-1267
<ul>
<li>⏱ 2023-10-25 20:48:58</li>
</ul>
</li>
</ul>
<h2><a id="%E5%93%81%E7%89%8C%E5%BB%BA%E8%AE%BE%E7%9A%84%E6%A0%B8%E5%BF%83%E5%9B%A0%E7%B4%A0%E6%98%AF%E8%AF%9A%E4%BF%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>品牌建设的核心因素是诚信</h2>
<ul>
<li>📌 诚信是企业的立身之本 ^31418150-7-2108-2118
<ul>
<li>⏱ 2023-10-25 20:54:35</li>
</ul>
</li>
</ul>
<h2><a id="%E4%B8%8D%E6%83%B3%E5%81%9A%E4%BB%A3%E5%B7%A5%E5%8E%82%EF%BC%8C%E5%B0%B1%E8%A6%81%E5%8A%A0%E5%A4%A7%E7%A0%94%E5%8F%91%E6%8A%95%E5%85%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不想做代工厂，就要加大研发投入</h2>
<ul>
<li>📌 技术开发的动力是为了生存 ^31418150-8-2730-2742
<ul>
<li>⏱ 2023-10-25 20:58:38</li>
</ul>
</li>
</ul>
<h2><a id="%E7%AE%A1%E9%81%93%E6%88%98%E7%95%A5%EF%BC%9A%E6%8A%8A%E5%8A%9B%E9%87%8F%E9%9B%86%E4%B8%AD%E5%9C%A8%E4%B8%BB%E8%88%AA%E9%81%93%E4%B8%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>管道战略：把力量集中在主航道上</h2>
<ul>
<li>📌 管道战略是指把经营战略的重点放在一个特定的目标上，为特定的地区或特定的购买群体提供产品或服务，以便迅速巩固基本盘。 ^31418150-12-819-876
<ul>
<li>⏱ 2023-10-25 21:06:50</li>
</ul>
</li>
</ul>
<h2><a id="%E4%BC%81%E4%B8%9A%E5%BF%85%E9%A1%BB%E4%BF%9D%E6%8C%81%E5%90%88%E7%90%86%E7%9A%84%E6%88%90%E9%95%BF%E9%80%9F%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>企业必须保持合理的成长速度</h2>
<ul>
<li>
<p>📌 企业经营的核心首先是生存和发展，最终目的是盈利 ^31418150-14-1880-1903</p>
<ul>
<li>⏱ 2023-10-27 21:41:58</li>
</ul>
</li>
<li>
<p>📌 企业的创新有三种模式：第一种是营销创新 ^31418150-14-2071-2090</p>
<ul>
<li>⏱ 2023-10-27 21:43:28</li>
</ul>
</li>
<li>
<p>📌 第二种是市场创新 ^31418150-14-2133-2141</p>
<ul>
<li>⏱ 2023-10-27 21:43:38</li>
</ul>
</li>
<li>
<p>📌 第三种是产品创新 ^31418150-14-2201-2209</p>
<ul>
<li>⏱ 2023-10-27 21:43:44</li>
</ul>
</li>
</ul>
<h1><a id="%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>读书笔记</h1>
<h1><a id="%E6%9C%AC%E4%B9%A6%E8%AF%84%E8%AE%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>本书评论</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebGL光照渲染立方体]]></title>
    <link href="https://www.bwrong.cn/17280514986441.html"/>
    <updated>2024-10-04T22:18:18+08:00</updated>
    <id>https://www.bwrong.cn/17280514986441.html</id>
    <content type="html"><![CDATA[
<p>光线照在物体上，物体反射光线就会构成一个光场，眼睛看到生活中的物体有立体感就是因为有光的存在。因此在学习物理光学在WebGL编程中如何应用， 你就要先了解基本的光学知识。</p>
<p>生活中你看到一个红色立方体，从宏观的角度来看你会描述他是红色的，或者描述RGB值为(1,0,0)的立方体，这时候你要问自己一个问题， 如果呈现到眼睛中的红色平面图像，如果颜色是均匀的，你是否还有立体的感觉。换句话说就是如果把你看到的立方体图像分割成一个个像素单位， 那么每一个像素的RGB值都是(1,0,0)的话你是否有立方体的空间感，从前面课程的实验可以知道，是没有任何空间感的。 那就说明一个问题实际上在自然界中你看到的物体图像，如果看做一个光场，它就是一个变化的光场，并不是每个像素都是(1,0,0)。 这很好理解，抛开专业的物理光学不谈，其实生活中你会发现，比如太阳光照射到一个物体上，不同的面与光的角度不同，反射的到眼睛中的结果不同， 向阳面亮，背光面暗，不同的面不同的颜色，分界位置就有棱角感，。比如一个白色LED灯，靠近表面放在表面的中心， 你会感到表面反射到眼睛中的效果是越往四周越暗。</p>
<h2><a id="%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>光照模型</h2>
<h3><a id="%E6%BC%AB%E5%8F%8D%E5%B0%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>漫反射</h3>
<p><figure><img src="media/17280514986441/17281451179876.png" alt="WebGL光照模型入射角" /><figcaption>WebGL光照模型入射角<figcaption></figure> <figure><img src="media/17280514986441/17281451179895.png" alt="WebGL漫反射" /><figcaption>WebGL漫反射<figcaption></figure></p>
<p>没有绝对的真理或迷信，所有的理论都是对生活现象的概括描述，上面提到一个几何体在太阳光下不同的面明暗不同，太阳离地球比较远，太阳光可以视为平行光，几何体不同的面与平行太阳光光线夹角不同， 换句话说就是相同强度的光线照射在表面上角度不同反射光线的强度也就不同，这里就对个现象建立数学模型。</p>
<p>漫反射光的颜色 = 几何体表面基色 x 光线颜色 x 光线入射角余弦值</p>
<p>这个数学模型没有考虑镜面反射描述的就是理想的漫反射体，并不能完整的描述物体表面的光场，既然是数学模型，自然就是可以修正的，比如添加一个系数，更改指数等等，这里不在详述。 比如普通的桌子桌面它的粗糙度是微米um级，相比人的脸它是平的，光的波长是纳米nm级，这时候桌子表面相比光线是凹凸不平的，宏观来看一束光线照射到物体的表面，对于理想的漫反射而言，因为表面无规则随机分布凹凸不平的反射面， 光线的反射是不定向的，换句话说任何角度的反射光都是一样的，这也就是说物体反射到眼睛中的光与人的观察位置无关，物体的漫反射光强度与光线的入射角有关如何解释，这个其实很简单，比如两块纸板面积相同，一个垂直太阳光线放置， 一个不垂直太阳光线也就是入射角不是90度，同样强度的光照条件下，垂直太阳光的纸板的光通量肯定比斜着放的纸板接收的光量大，这时候就有必要给数学模型引入一个入射角的因数。</p>
<p><figure><img src="media/17280514986441/17281451179906.png" alt="漫反射余弦值" /><figcaption>漫反射余弦值<figcaption></figure> <figure><img src="media/17280514986441/17281451179916.png" alt="WebGL漫反射——0度" /><figcaption>WebGL漫反射——0度<figcaption></figure></p>
<p>光的颜色可以使用多种模型来表示，把上面的文字公式使用RGB具体参数来表示形式如下，比如物体表面的颜色是纯红色(1,0,0),入射光是纯白色(1,1,1),光线入射角是60度，余弦值就是0.5，代入下面公式，可以得出结果是(0.5,0,0), 结果仍然是红色，这是符合实际生活的，白色太阳光照在常见的红色物体上，反射的颜色是红色，只是太阳光线照射在物体表面的角度不同，反射的光强度不同。入射光垂直物体表面，也就是入射角是0对应的余弦值是1，光线垂直表面受光量最大， 反射光自然最大，和1对应；入射光线平行物体表面，此时的入射角是90度， 物体表面自然没什么光可以反射，</p>
<p>(R2,G2,B2) = (R1,G1,B1) x (R0,G0,B0) x cosθ</p>
<h3><a id="%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>镜面反射</h3>
<p><figure><img src="media/17280514986441/17281451179925.png" alt="WebGL环境光模型" /><figcaption>WebGL环境光模型<figcaption></figure> <figure><img src="media/17280514986441/17281451179939.png" alt="WebGL镜面反射" /><figcaption>WebGL镜面反射<figcaption></figure></p>
<p>上面的漫反射数学模型没有考虑镜面反射，描述的就是理想的漫反射体，并不能完整的描述物体表面的光场。漫反射是因为几何体表面粗糙度尺寸相对光波长尺寸而言是凹凸不平的，这种凹凸不平又是随机的，所以说漫反射的光线各个方向是均匀的。 镜面反射也就是说光照在物体上的反射光线具有方向性，具体点说就是光线的反射角等于入射角。生活中的镜子它的表面粗糙度很小，和光的波长是一个数量级，当光线照在上面的时候，反射光线就会表现出方向性。</p>
<p>实际的生活中所有的物体没有绝对的漫反射或者镜面反射，往往都是同时存在，只是表现的倾向性不同，镜子的镜面反射更明显，粗糙的树皮漫反射更明显。光照射到物体上一部分会被吸收，透明的话一部分会被折射， 除去吸收和折射的光剩余的会被反射，反射的时候根据表面的粗糙度不同，镜面反射和漫反射分配的比例不同可以使用两个系数k1、k2去描述。</p>
<p>在室外停放着一辆车，你观察车的时候，你会发现车的外表面会在某个局部出现高光，这很好理解，车的外壳是曲面的，曲面上如果某个区域的的光线反射角刚好是你的视线方向，自然会呈现出局部高亮的现象，其他的部位是漫反射为主。 镜面反射的公式仍然可以写成上面的形式，只是角度不再是光线入射角度而是眼睛视线与反射光线的夹角，n角度余弦值的指数，实际编程的时候你可以自由定义，没有绝对完美的模型，都可以进行修正。</p>
<p>镜面反射光的颜色 = 几何体表面基色 x 光线颜色 x 视线与反射光线的夹角余弦值n</p>
<h3><a id="%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>环境光照</h3>
<p>在暗的环境下，物体比较暗，光亮的环境下，物体比较光亮，描述这个现象可以使用环境光照模型。光线在自然环境中会在不同的物体之间来回反射，单束的光线具有方向性，所有方向的光线随机分布，形成一个没有特殊的光线方向的的环境光照。 多数情况下室内室外环境光颜色通常都是RGB相同的白色到黑色之间的值，(1,1,1)表示最强的环境光照颜色，(0,0,0)相当于处于完全的没有光照的黑色环境中。</p>
<p>环境反射光颜色 = 几何体表面基色 x 环境光颜色</p>
<h3><a id="%E5%A4%8D%E5%90%88%E5%85%89%E7%85%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复合光照</h3>
<p>使用光照渲染模型的时候往往会使用多种光照模型，然后把每个光照模型颜色相乘的结果RGB分别相加，这时候要注意，多种模型的光照颜色相加后RGB的值要保证在区间[0,1]，因为WebGL的RGB颜色模型默认RGB分量的最大值是1，注意分配比例即可。</p>
<p>总反射光线 = 漫反射光线 + 镜面反射光线 + 环境反射光线</p>
<h3><a id="%E6%B3%95%E5%90%91%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>法向量</h3>
<p>有基本的数学知识应该都有法线的概念，垂直与面的直线就是面的法线，对于平面而言面上所有位置的法线方向是相同的，对于曲面而言不同的位置法线的方向是变化的。在三维笛卡尔坐标系中，可以使用向量(x,y,z)来表示法向量，根据几何体表面的法向量和光线的方向， 就可以求解出光线入射角的余弦值，法向量的点积计算满足下面的公式，为了方便计算，着色器语言内置了一个方法dot()用来求解两个向量之间的余弦值,已知向量a1(x1,y1,z1)、a2(x2，y2，z2)执行dot(a1，a2)可以求出两个向量a1、a2的余弦值。</p>
<p><figure><img src="media/17280514986441/17281451179952.png" alt="WebGL法向量" /><figcaption>WebGL法向量<figcaption></figure></p>
<p><figure><img src="media/17280514986441/17281451179963.png" alt="WebGL法向量计算" /><figcaption>WebGL法向量计算<figcaption></figure></p>
<h2><a id="%E7%AB%8B%E6%96%B9%E4%BD%93%E6%B7%BB%E5%8A%A0%E5%B9%B3%E8%A1%8C%E5%85%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>立方体添加平行光</h2>
<p><a href="http://www.yanhuangxueyuan.com/WebGL_course/download/light.rar">源码下载</a></p>
<p>下面的案例是通过给一个单色的立方体添加平行光进行渲染，来体会光照模型在物体渲染中的应用，在学习下面的代码之前确定你有逐顶点和颜色插值计算的概念，了解顶点位置数据、顶点颜色数据，本节课在这两种顶点数据的基础之上在引入一种新的顶点数据。</p>
<p>平行光照射在立方体上，与不同的平面夹角不同，自然反射的颜色RGB值强弱不同，实际绘图的时候你不可能手动计算去定义每一个像素的值，前面课程中讲解颜色插值计算的知识，应该对你有一定的启发，你只需要计算出每一个顶点在光照下的颜色， 然后利用插值计算就可以得到三个顶点之间区域的像素值，这时候顶点法向量数据就派上了用场，每一个顶点都有位置数据、颜色数据、法向量数据，法向量和颜色数据先进行计算得出新的顶点颜色数据，然后渲染管线对顶点进行装配光栅化的过程中，新的顶点颜色数据进行插值计算。 这时候提示一下大家，不要去从宏观思考法向量问题，要从逐顶点、插值计算的角度理解问题，下面的问题可能大家会有一个疑问，为什么立方体的一个顶点会有三个方向，从实际的物体来看，立方体的一个顶点就是一个顶点，但是从绘图的角度来看， 每一次是通过三个顶点绘制一个三角形面，只不过恰好三个三角形面共顶点，会有顶点位置重复而已，但是每一组的三个顶点是一个装配光栅化和插值计算的独立单元，两组的三个顶点位置有重复也不会影响他们各自的渲染得到的像素结果。</p>
<h3><a id="%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>顶点着色器：添加变量</h3>
<pre class="line-numbers"><code class="language-plain_text">16   /**用于光照计算的变量a_normal、u_lightColor、u_lightDirection**/
17   'attribute vec4 a_normal;' +//法向量变量
18   'uniform vec3 u_lightColor;' + //uniform声明平行光颜色变量
19   'uniform vec3 u_lightDirection;' + //平行光方向
20   'varying vec4 v_color;'+//varying声明顶点颜色插值后变量
</code></pre>
<p>查看上面的代码大家可以发现一个新的关键字uniform，着色器语言中声明变量的关键词就是attribute、uniform、varying这三个关键字，在Javascript语言中只有一个var或ES6中的let，这主要是因为着色器语言的特殊性， 不同的关键字顶标着不同的功能，初学者可能比较混乱，不知怎么区分，下面进行简单总结，为了课程讲解渐进性，不做过多总结，紧密结合代码总结。</p>
<p>attribute关键字大家课程中最早讲解，大家可以看到它都是出现在顶点着色器的代码中， 声明的变量往往与顶点数据相关，比如顶点位置坐标、顶点颜色值和本节课的顶点法向量数据，attribute关键字声明的顶点变量而且可以通过方法getAttribLocation()获取顶点数据的索引位置， 然后利用方法vertexAttribPointer()可以把类型数组创建的顶点数据传递给顶点着色器，然后逐顶点处理计算。你可以观察到这些方法中都有Attrib，通过名字就可以大致判断它的作用。</p>
<p>varying关键字在颜色插值计算中往往会使用，在顶点着色器代码第20行中声明了一个变量v_color，每个顶点的颜色与法向量进行乘法运算后，第49行进行赋值计算，等于告诉渲染管线离散的顶点颜色进行插值计算，去填充顶点之间的片元像素值， 为了完整实现这一点，需要在片元着色器代码中同样使用关键字varying再次声明该变量，这样的话插值后的颜色值会地递给片元着色器，通过执行第56行语句gl_FragColor = v_color，把片元对应的颜色值赋值给片元。</p>
<p>uniform关键字和attribute共同的作用是可以接收数据，不同点是接收的数据不同，attribute关键字声明顶点数据，这些数据会逐顶点处理，查看代码第18行第19行可以看出uniform关键字声明的数据不是顶点数据，这些数据往往都会重复利用，每个顶点进行计算的时候都会用到， 每个顶点对应的数据会有坐标、颜色、法向量等，但是光线的颜色和方向对于所有的顶点都是通用的，这些说明uniform关键字主要用于声明哪些会被重复利用的数据，比如光线颜色、光线方向、光线位置、模型变换矩阵。学习后面的课程可以看到uniform关键字也会用到片元着色器中， 这里没有用到就不展开讲解，不过attribute关键字只是用在顶点着色器中，一般用来接收各种类型的顶点信息。</p>
<p>代码第18行第19行都有一个关键字vec3，vec3和float、vec4、mat4一样都表示一种数据类型，vec3数据(a,b,c)可以用来表示三维坐标系中的向量，例如光线的方向、光线的颜色RGB，vec4可以用来表示顶点位置的齐次坐标(x,y,z,w), 包含透明度的RGB颜色模型RGBA(r,g,b,a),顶点的法向量。</p>
<h3><a id="%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%EF%BC%9A%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>顶点着色器：光照计算</h3>
<p>dot()是着色器语言内置的一个函数方法，它的参数是两个向量，执行结果是两个向量的点积，如果光线方向向量和顶点法向量两个向量都是单位向量，求解的结果就是平行光线与物体表面法线夹角的余弦值。 这也是为什么要执行第43行代码的原因，normalize()和dot()一样都是着色器语言内置的函数方法用于数学计算，它的作用就是把向量归一化，具体点说就是如果向量的模长不是1，不改变向量方向，把模长变为1，也就是把向量转化为单位向量， a_normal在第17行代码中定义的是vec4类型，第四个参数默认是1主要是为了凑成齐次坐标用于矩阵计算，表示法向量方向的是前三个参数，所以执行a_normal.xyz就相当于访问法向量的xyz值，返回的结果是一个vec3数据，如果执行vec3.xy相当于返回一个vec2数据， 如果一个顶点的a_normal数据是(1,1,1，1)，那么它的模长就不是1，而是3的平方根，这时候需要把前三个1全部除以3的平方根才可以把非单位向量转化为单位向量。</p>
<p>第45行代码在dot代码的外面嵌套了一个函数max()，dot()的计算结果作为max()的第一个参数，dot的计算结果可能是[-1,1]之间，颜色不存在负值要舍去[-1,0),这时候就是max()方法派上用场的时候，第45行代码中max()函数的第二个参数是0， dot()方法的计算结果会和0进行比较运算，返回一个较大的值，着色器语言内置提供了max()函数，自然也有对应的求较小值的函数min()。余弦值是负值的物理意义就是光线无法照的地方，临界点是余弦值0，入射角是90度，也就是说入射光线平行平面， 平行平面相当于光线没有照射到平面上，平面没有收到光自然无法反射光，你可以尝试改变立方体顶点的旋转矩阵可以看到一些面的颜色是黑色，就是因为没有光线照射，这一点是复合实际生活和物理规律的，不管是提本身是什么颜色，没有外界光源，那就表现为黑色。</p>
<p>第47行代码是套用理想漫反射光照模型的一个公式进行计算，a_color变量是vec4类型包含透明度，计算式中没有计算透明度A，所以使用a_color.rgb语句返回a_color数据的RGB三个分量，也就是返回一个vec3类型数据。</p>
<p>第49行代码是通过把经顶点法线乘过的顶点颜色赋值给varying声明的一个变量实现颜色的插值计算，关于插值计算不在多谈，这里说一下着色器语言数据类型的相关转化、构造、访问相关问题，vec4、vec3等都是和float、int一样是数据类型的标识关键字，float、int在C语言中都是常见的类型， 着色器语言为了实现大规模的顶点运算增加了很多数据类型，vec4()、vec3()这时候的表达相当于一个vec4、vec3数据的构造函数，第49行代码中把一个vec3类型数据和一个vec4类型数据的一个分量a作为构造函数vec4的两个参数，来实现创建一个vec4类型数据。访问多元素数据的分量可使用点符号，从面对象的角度来看， 一个数据家是一个对象，数据的一个元素就是数据的一个分量，比如 a_color.a表示vec4类型数据 a_color的透明度分量a。</p>
<pre class="line-numbers"><code class="language-plain_text">42   // 顶点法向量归一化
43   '  vec3 normal = normalize(a_normal.xyz);' +
44   // 计算平行光方向向量和顶点法向量的点积
45   '  float dot = max(dot(u_lightDirection, normal), 0.0);' +
46   // 计算平行光方向向量和顶点法向量的点积
47   '  vec3 reflectedLight = u_lightColor * a_color.rgb * dot;' +
48   //颜色插值计算
49   '  v_color = vec4(reflectedLight, a_color.a);' 
</code></pre>
<h3><a id="%E8%8E%B7%E5%8F%96%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取着色器变量</h3>
<p>要想给着色器程序中声明的变量传递数据，首先要获取数据的地址，然后通过指针地址传递给变量。要想获取变量地址，不可能像普通CPU变成一样，要考虑GPU的特殊性，首先要通过59行代码调用初始化着色器函数，把着色器程序通过CPU与GPU的通信传递给GPU配置渲染管线， 执行执行初始化着色器函数的同时会返回一个program对象，通过对象program可以获取着色器程序中的变量，getAttribLocation()方法用来获取attribute关键字声明的定点变量地址，getAttribLocation()方法获取uniform关键字声明的统一变量地址。</p>
<pre class="line-numbers"><code class="language-plain_text">60   /**
61    * 从program对象获取相关的变量
62    * attribute变量声明的方法使用getAttribLocation()方法
63    * uniform变量声明的方法使用getAttribLocation()方法
64    **/
65   var aposLocation = gl.getAttribLocation(program,'apos');
66   var a_color = gl.getAttribLocation(program,'a_color');
67   var a_normal = gl.getAttribLocation(program,'a_normal');
68   var u_lightColor = gl.getUniformLocation(program,'u_lightColor');
69   var u_lightDirection = gl.getUniformLocation(program,'u_lightDirection');
</code></pre>
<h3><a id="%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>传递数据</h3>
<p>对于简单的数据，不像顶点有大批量数据，不需要在显存上开辟缓冲区上传数据，可以直接使用uniform3f()方法使用把数据传递给GPU，uniform3f(变量地址,x,y,z)表示传递三个浮点数，接收这个数据的变量是vec3类型,uniform2f(变量地址,x,y)表示传递2个浮点数,接收数据的变量是vec2数据类型， 以此类推还有方法uniform4f()、uniform1f()，命名的特点是数字表示传递的数据有多少分量，f是关键字float的缩写表示浮点数。</p>
<p>u_lightDirection变量在程序中要保证是单位向量，所以第15行的代码的书写方式保证了灯光方向向量的方向是(1,2,-3),(1,2,-3)的模长是15的平方根，所以要除以Math.sqrt(15)，实际的开发中一般不是这样手动计算写出来，而是写一个通用的归一化函数可以随时调用， 这里为了简化教学代码，直接手动计算好在输入数据。</p>
<pre class="line-numbers"><code class="language-plain_text">70   /**
71    * 给平行光传入颜色和方向数据，RGB(1,1,1),单位向量(x,y,z)
72    **/
73   gl.uniform3f(u_lightColor, 1.0, 1.0, 1.0);
74   //保证向量(x,y,z)的长度为1，即单位向量
75   var x = 1/Math.sqrt(15), y = 2/Math.sqrt(15), z = 3/Math.sqrt(15);
76   gl.uniform3f(u_lightDirection,x,y,-z);
</code></pre>
<h3><a id="%E9%A1%B6%E7%82%B9%E6%B3%95%E5%90%91%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>顶点法向量</h3>
<p><figure><img src="media/17280514986441/17281451179973.png" alt="WebGL顶点法向量" /><figcaption>WebGL顶点法向量<figcaption></figure></p>
<p>对于立方体而言六个平面也就是有六个不同的平面法向量，但是这里要注意思考如何表达一个面的法向量，你不能说直接告诉GPU一个平面的法向量是(x,y,z)，对于立方体而言而言这样比较简单，符合人的思维，但是如果是复杂的曲面这样并不合适，而且顶点着色器是逐顶点处理， 为了表示面的法向量，往往是通过顶点，具体点说是每个顶点对应一个法向量，三个顶点确定一个三角面，三角面的不同位置的法向量相当于通过他的三个顶点的法向量插值得出，或者换个说法就是三个顶点的法向量分别与各自颜色数据进行乘法运算，得到新的顶点颜色， 然后渲染管线利用新的顶点颜色进行插值计算，这就是通过顶点法向量表示面法向量的方法，通过这样的巧妙设计还可以实现法向量的插值计算，只不过插值是通过颜色插值完成的，对于平滑的曲面，过每一个顶点存在一个法平面，也就是有一个法向量，往往在不同三角面中同一位置的顶点法向量是相同的， 对于规则的长方体而言，每个顶点法向量往往在各自平面中有不同的值。</p>
<pre class="line-numbers"><code class="language-plain_text">99   /**
100   *顶点法向量数组normalData
101   **/
102  var normalData = new Float32Array([
103  0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,//z轴正方向——面1
104  1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,//x轴正方向——面2
105  0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,//y轴正方向——面3
106  -1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,//x轴负方向——面4
107  0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,//y轴负方向——面5
108  0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1//z轴负方向——面6
109  ]);
</code></pre>
<h2><a id="%E9%A1%B6%E7%82%B9%E6%B3%95%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>顶点法向量矩阵变换</h2>
<p>不知大家是否注意到上面的顶点法向量数据并不是立方体的外表面的法向量，主要是因为立方体的顶点坐标经过了旋转矩阵变换，不管是顶点的坐标还是顶点的法向量都是相对WebGL坐标系而言， 顶点法向量数据和顶点位置数据并没有关联关系，因此没有随着顶点位置数据的旋转而变化，正是因为这一点，你可以尝试更改着上面案例色器程序中立方体顶点的旋转变换角度， 可以看到有些表面，它的法向量和平行光光线的夹角虽然小于90度，也就是说能被光线照射到，但是它的显示颜色却是黑色，这正是因为顶点坐标虽然经过了旋转变换，但是顶点法向量没有跟着变化， 本节课的内容就是为大家解析如何利用矩阵乘法运算实现顶点法向量的跟随顶点位置同步旋转。</p>
<h3><a id="%E6%97%8B%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>旋转、平移变换</h3>
<p>三维模型的几何变换有平移、缩放、旋转、剪切、镜像等多种，这里就简单分析下旋转变换和平移变换对顶点法向量的影响，几何体平移变换后，几何体表面相对坐标系原点整体偏移，物体的表面相对坐标轴并没有发生旋转， 几何体表面的法平面法线没有变化，也就是说平移矩阵左乘顶点坐标后，顶点的法向量数据不变化不会影响光照计算。几何体旋转变换后，它的表面相对坐标轴发生了旋转，表面的法线自然发生变化， 一个几何体在计算机图形中的描述是一个个顶点，在几何体旋转的过程中，顶点的法向量和顶点的位置坐标是同步旋转变换的，顶点位置变换是通过旋转矩阵乘法运算实现， 也就是说顶点的法向量也乘同样的旋转矩阵就可以保证几何体表面的法线随着几何体旋转而旋转。</p>
<p>在上节课的代码中直接修改顶点着色器代码即可。</p>
<pre class="line-numbers"><code class="language-plain_text">42   // 顶点法向量归一化
43   '  vec3 normal = normalize(a_normal.xyz);' 
</code></pre>
<p>旋转矩阵mx、my连乘后，再乘以顶点法向量a_normal,这时候你可以随意更改旋转角度，通过观察颜色可以知道立方体顶点的法向量对着立方体旋转而旋转。</p>
<pre class="line-numbers"><code class="language-plain_text">42   // 顶点法向量归一化
43   '  vec3 normal = normalize((mx*my*a_normal).xyz);' 
</code></pre>
<h3><a id="%E5%A4%8D%E5%90%88%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复合变换</h3>
<p>如果几何体发生多次旋转，也就意味着几何体的表面法线相对坐标系也发生多次旋转变换，把多个旋转变换矩阵连乘，再乘以顶点法向量构成的列向量即可，这一点和顶点位置坐标旋转变换计算一样。</p>
<p>如果几何体先后进行旋转、平移变换，假设旋转矩阵为A，平移矩阵为B，矩阵AB连乘后得到复合矩阵C，C再乘以顶点位置齐次坐标，就可以得到复合变换后的顶点坐标，对于顶点法向量而言直接右乘旋转矩阵A即可， 不需要关注平移矩阵A，实际的编程中几何体可能发生非常多次平移矩阵、旋转矩阵，没有必要再计算一遍旋转矩阵连乘，可以利用复合矩阵C来求解几何变换后的顶点法向量，但是要矩阵C进行一定变换，才能再乘以顶点法向量。 这很好理解，你可以使用平移矩阵乘以一个顶点法向量，可以看得到顶点法向量的值发生变化，前面说过几何体平移不影响顶点法向量，因为复合矩阵C是包含平移矩阵的成分的，如果使用复合矩阵C直接乘以顶点法向量， 结果是不准确的。这时候线性代数的逆矩阵和转置矩阵知识就派上了用场，你可以把任意一个平移矩阵先利用初等变换的方法求解逆矩阵，再进行转置变换，也就是说求解出一个平移矩阵的逆转置矩阵，把逆转置矩阵与顶点法向量相乘， 你会发现得到的结果，顶点法向量前三个参数的值并没有发生变化，第四个参数发生了变化，不过这无所谓，进行光照计算的时候只会选择前三个参数，第四个参数只是用来辅助计算。这也就说明如果对复合矩阵C进行逆转置变换， 就可以消除平移矩阵对顶点法向量的影响，这时候会带来一个问题，复合矩阵C逆转置变化的过程中，它包含的旋转矩阵相当于也被执行了相同的变换，不过这不影响光照计算，因为旋转矩阵是正交矩阵，它的逆转置矩阵就是它本身， 正交矩阵的乘积仍然是正交矩阵，也就是说多个旋转矩阵相乘后，它的逆转置矩阵仍然是自身。</p>
<h3><a id="%E8%A7%86%E7%BA%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>视线</h3>
<p>课程在<a href="http://www.yanhuangxueyuan.com/WebGL_course/coordinate.html">《WebGL坐标系》</a>中讲解过WebGL图形系统默认的投影方向，或者说人的眼睛观察几何体的方向，或者说照相机拍照的方向。 代码中的灯光方向的向量数据，第三个参数是负数，也就是说从z轴的角度看，平行光照射物体的方向，就是人眼睛看物体的方向，如果把灯光方向的向量数据z参数更改为正数，刷新浏览器看到的是一个漆黑的立方体投影， 这时候相当于黑暗的环境中，人站在物体的背光面，而不是向光面，对于WebGL图形系统，你可以形象的理解为把光源从屏幕前面放到了屏幕的后面，人的观察方向是沿着z轴负方向，从屏幕外向里观察，光线自然被立方体遮挡住了。</p>
<pre class="line-numbers"><code class="language-plain_text">75       var x = 1/Math.sqrt(15), y = 2/Math.sqrt(15), z = 3/Math.sqrt(15);
76       gl.uniform3f(u_lightDirection,x,y,-z);
</code></pre>
<p>灯光方向向量数据第三个参数，也就是z轴方向的数值更改为正数。</p>
<pre class="line-numbers"><code class="language-plain_text">75       var x = 1/Math.sqrt(15), y = 2/Math.sqrt(15), z = 3/Math.sqrt(15);
76       gl.uniform3f(u_lightDirection,x,y,z);
</code></pre>
<h2><a id="%E7%AB%8B%E6%96%B9%E4%BD%93%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%85%89%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>立方体添加点光源</h2>
<p><a href="http://www.yanhuangxueyuan.com/WebGL_course/download/light1.rar">源码下载</a></p>
<p>添加平行光是直接定义光线照射物体的方向，点光源的光线是发散的，无法直接定义它的光线方向，不过只要定义好点光源的位置坐标，然后与某个顶点的位置坐标进行减法运算，计算结果就是光源射到该顶点的方向。 这很好理解，在三维空间中两个点确定一条直线，几何体顶点代表一个点，点光源的位置代表一个点，直线所在的方向就是光线的方向，在三维笛卡尔坐标系中，把两个顶点的xyz三个分量相减就可以得到一个表示直线方向的向量， 把该向量和顶点法向量作为dot()点积函数的参数，可以计算出光线入射角余弦值然后代入漫反射光照模型公式可以得到新的顶点颜色，渲染管线利用新的顶点颜色进行插值计算可以得到立方体表面每一个像素的值。</p>
<h3><a id="%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%85%89%E6%BA%90%E4%BD%8D%E7%BD%AE%E3%80%81%E9%A2%9C%E8%89%B2%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加点光源位置、颜色数据</h3>
<p>点光源的颜色数据是使用WebGL接口uniform3f()方法传入着色器中，点光源的位置数据是使用着色器语言GLSL ES直接定义在顶点着色器程序中，这两种方式实现的结果都是一样的，通过这个对比你可以进一步着色器语言和Javascript语言可以操控的可以实现CPU和GPU通信的WebGL API。</p>
<pre class="line-numbers"><code class="language-plain_text">40   /**设置点光源位置数据**/
41   'vec3 lightPosition = vec3(2,3,4);'
76   /**
77    * 传入点光源颜色数据
78    **/
79   gl.uniform3f(u_lightColor, 1.0, 1.0, 1.0);
</code></pre>
<h3><a id="%E8%AE%A1%E7%AE%97%E5%85%89%E7%BA%BF%E6%96%B9%E5%90%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算光线方向</h3>
<p>点光源的光线是发散的，点光源与每一顶点连线的方向都需要单独计算。第47行代码的功能是计算经过旋转变换后的顶点坐标，这样可以保证光线方向随着立方体旋转动态变化，尤其是制作旋转动画。</p>
<p>第49行代码用来计算光线方向，然后利用内置函数 normalize()归一化向量数据，vec3(vertexPosition)和vertexPosition.xyz的写法是等效的，都是为了提取vec4类型顶点数据前三个分量，返回的数据类型是vec3，比如vec2(vec4)就是提取vec4的前两个分量。</p>
<pre class="line-numbers"><code class="language-plain_text">46   // 计算顶点位置
47   '  vec4 vertexPosition = mx*my*apos;' +
48   // 计算点光源照射顶点的方向并归一化
49   '  vec3 lightDirection = normalize(vec3(vertexPosition) - lightPosition);' 
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用微信第三方平台发布零码小程序]]></title>
    <link href="https://www.bwrong.cn/17280336310867.html"/>
    <updated>2024-10-04T17:20:31+08:00</updated>
    <id>https://www.bwrong.cn/17280336310867.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%9A%BE%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>难点</h2>
<ul>
<li>将设计好的应用生成原生小程序代码：因为编辑时和运行时环境差异性，导致不能使用同一套代码，需要针对不同平台有不同的实现（实现方案二）。</li>
<li>将设计好的应用发布到商家自己的小程序中，需要对接微信第三方平台能力，主要是因为对这套发布流程不熟悉。</li>
</ul>
<h2><a id="%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现方案：</h2>
<hr />
<h3><a id="%E4%B8%80%E3%80%81webapph5%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%9A%E5%A4%8D%E7%94%A8h5%E7%89%88%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、WebApp/H5小程序：复用H5版本</h3>
<p>在H5版本上，通过小程序<a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html">Webview</a>开放能力组件实现H5页面动态渲染，通过传入H5地址方式，实现不同程序内容展示。</p>
<p><strong>特点：</strong></p>
<ul>
<li>实现简单，因为和编辑时使用的是同一环境，****可直接复用，不需要做单独适配。</li>
<li>能力有限，因为使用Webview进行渲染，所以应用所能使用的能力取决于Webview组件提供的开发能力，目前可以使用的能力可查看<a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html#%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3-2">Webview组件文档</a></li>
</ul>
<p><figure><img src="media/17280336310867/17281439430594.jpg" alt="" /></figure></p>
<h3><a id="%E4%BA%8C%E3%80%81%E5%8E%9F%E7%94%9F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%A1%88%EF%BC%9A%E7%94%9F%E6%88%90%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、原生小程序方案：生成小程序原生组件</h3>
<p>在web端进行应用设计完成后，将内容保存为和平台无关的通用语言数据，常用的为JSON Schema，不同平台需要实现各自的解析适配器，将内容解析为平台特有的代码，这里即为解析为微信小程序。</p>
<p><strong>特点：</strong></p>
<ul>
<li>实现复杂，两个平台差异性太大，需要实现多套解析器和组件。不过可以通过使用多端开发框架（<a href="https://uniapp.dcloud.net.cn/">uniapp</a>、<a href="https://taro.jd.com/">taro</a>）来降低差异性。</li>
<li>能力受限小，因为是生成原生组件，基本上可以使用所有原生组件能力。</li>
</ul>
<pre class="line-numbers"><code class="language-json">{
  &quot;label&quot;: &quot;新增组件&quot;,
  &quot;icon&quot;: &quot;icon-zujian&quot;,
  &quot;fields&quot;: {
    &quot;color_gi&quot;: {
      &quot;label&quot;: &quot;颜色选择器&quot;,
      &quot;type&quot;: &quot;color&quot;,
      &quot;value&quot;: &quot;&quot;
    },
    &quot;string_Ao&quot;: {
      &quot;label&quot;: &quot;输入框&quot;,
      &quot;type&quot;: &quot;string&quot;,
      &quot;value&quot;: &quot;&quot;,
      &quot;options&quot;: {
        &quot;placeholder&quot;: &quot;请输入&quot;
      }
    },
    &quot;upload_6t&quot;: {
      &quot;label&quot;: &quot;图片上传&quot;,
      &quot;type&quot;: &quot;upload&quot;,
      &quot;value&quot;: &quot;&quot;
    }
  }
}
</code></pre>
<p><figure><img src="media/17280336310867/17281439430614.jpg" alt="" /></figure></p>
<p><strong>参考实现方案：</strong></p>
<ul>
<li><a href="https://github.com/silence717/taro-designer">https://github.com/silence717/taro-designer</a></li>
<li><a href="https://github.com/ShaoGongBra/taro-design">https://github.com/ShaoGongBra/taro-design</a></li>
<li><a href="https://ext.dcloud.net.cn/plugin?id=6740">https://ext.dcloud.net.cn/plugin?id=6740</a></li>
<li><a href="https://pageplug.cn/">https://pageplug.cn/</a></li>
<li><a href="https://github.com/staringos/mtbird">https://github.com/staringos/mtbird</a></li>
</ul>
<h2><a id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0%E4%BB%A3%E5%BC%80%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何使用第三方平台代开发</h2>
<p>第三方平台（简称第三方平台），由微信团队面向所有通过<a href="https://kf.qq.com/faq/170824URbmau170824r2uY7j.html">开发者资质认证</a>的第三方开发者提供提供的官方平台。在得到公众号或小程序管理员授权后，基于该平台，第三方服务商可以通过调用官方接口能力，为商家提供公众号代运营、小程序代注册、代开发等服务以及提供公众号和小程序相关的行业方案、活动营销、插件能力等全方位服务。</p>
<p><figure><img src="media/17280336310867/17281439430632.png" alt="" /></figure><figure><img src="media/17280336310867/17281439430647.png" alt="" /></figure></p>
<h3><a id="%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>满足条件</h3>
<p><figure><img src="media/17280336310867/17281439430666.png" alt="" /></figure></p>
<ul>
<li>提供行业解决方案，如针对电商行业的解决方案，或针对旅游行业的解决方案等；</li>
<li>行业：（横向）提供更加专业的运营能力，精细化运营用户公众号或小程序；</li>
<li>功能：（纵向）对公众平台功能的优化，如专门优化图文消息视觉样式和排版的工具，或专门定制的 CRM 用户管理功能，或功能强大的小程序插件等。</li>
</ul>
<h3><a id="%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>流程</h3>
<p><figure><img src="media/17280336310867/17281439430682.png" alt="" /></figure></p>
<p><figure><img src="media/17280336310867/17281439430701.png" alt="" /></figure></p>
<h4><a id="%E4%B8%80%E3%80%81%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%95%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、如何成为服务商</h4>
<p>1、第三方平台帐号的审核无需缴费，但开放平台帐号的认证（即开发者资质认证）需要交300块钱认证费。一个已完成开发者资质认证的开放平台帐号，可创建5个平台型服务商第三方平台帐号。</p>
<p>2、任何合法合规的、为小程序提供开发服务及有意愿的开发者都可以成为小程序服务商，微信不会区别对待，也无官方授权的概念。</p>
<p><figure><img src="media/17280336310867/17281439430722.png" alt="" /></figure></p>
<p><a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/operation/thirdparty/prepare.html"><strong>准备材料：</strong></a></p>
<ul>
<li>官方网站：服务商应当有对外可用的官网，且该官网提供的服务描述与申请的第三方平台帐号名称、简介、图标均有所关联</li>
<li>平台图标：图标必须为当前服务商所有，不可使用其他企业的图标作为第三方平台帐号图标，108 x 108像素，大小不超过300KB，且格式为PNG的图片</li>
<li>域名和ssl证书</li>
</ul>
<h4><a id="%E4%BA%8C%E3%80%81%E6%90%AD%E5%BB%BA%E4%B8%89%E6%96%B9%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%EF%BC%9A%E8%87%AA%E5%BB%BA%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BA%91%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、搭建三方后端服务：自建模式和云服务</h4>
<p><figure><img src="media/17280336310867/17281439430744.png" alt="" /></figure></p>
<ul>
<li>服务商类型</li>
</ul>
<p><strong>平台型第三方平台帐号</strong></p>
<ul>
<li>这是官方推荐选择的类型，该类型的服务商可基于第三方平台接口能力，在获取商家扫码授权后，为商家提供代开发、代运营公众号和小程序服务。</li>
<li>想要为商家实现批量化服务，例如批量运营公众号、批量代开发小程序等，则需要选择该类型的帐号。</li>
</ul>
<p><strong>定制化型第三方平台帐号</strong></p>
<ul>
<li>当你不需要以服务商身份使用第三方平台接口能力，只需生成票据用于标记商家小程序是由该服务商开发的，那么可以选择创建该类型的帐号。</li>
<li>该类型的帐号仅有一个APPID用以作为服务商帐号id，没有secret，无法生成token，不可调用官方任何接口能力。该类型的服务商通常不基于第三方平台能力为商家提供服务。</li>
</ul>
<p>搭建好三方服务后需要和业务系统服务进行联调对接，然后进行<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/operation/thirdparty/publish.html">全网发布</a>。</p>
<h4><a id="%E4%B8%89%E3%80%81%E6%8E%88%E6%9D%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、授权</h4>
<p>商家需要将其公众号或者小程序<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Authorization_Process_Technical_Description.html">授权</a>给第三方平台，服务商才可以代商家进行相关操作。</p>
<p><figure><img src="media/17280336310867/17281439430767.png" alt="" /></figure></p>
<h4><a id="%E5%9B%9B%E3%80%81%E4%BB%A3%E5%95%86%E5%AE%B6%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、代商家调用接口</h4>
<p>小程序的api，服务商都可以调用，只是服务商调用的时候要使用<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/ThirdParty/token/api_authorizer_token.html">authorizer_access_token</a>，而不是access_token。</p>
<p>服务商能否代商家成功调用某个公众号或者小程序的api，取决于该公众号或者小程序管理员是否将对应的权限集授权给当前第三方平台帐号。</p>
<h4><a id="%E4%BA%94%E3%80%81%E4%BB%A3%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五、代开发小程序</h4>
<p><figure><img src="media/17280336310867/17281439430797.png" alt="" /></figure></p>
<h5><a id="%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码上传</h5>
<ul>
<li>通过开发者工具</li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/ci.html">CI代码上传</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/article/doc/0006aec26a89507900dc70f5e5b013?pass_ticket=PFmw0zP6yfVqUJz8iYlCaPgYBj0s6dm%2BoKU5cKthScDFPSrvwo9Z2cS1G9qCIrRyts29yPal4xRGPCSoPxxoeA%3D%3D">使用小程序CI自动上传代码</a></li>
</ul>
<p><figure><img src="media/17280336310867/17281439430830.png" alt="" /></figure></p>
<h3><a id="%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相关文档</h3>
<ul>
<li><a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/getting_started/terminology_introduce.html">官方文档</a></li>
<li><a href="https://developers.weixin.qq.com/doc/oplatform/openApi/OpenApiDoc/">API文档</a></li>
<li><a href="https://juejin.cn/post/6871397648792813575">微信开放平台之第三方平台开发，一整套流程</a></li>
</ul>
<h3><a id="%E7%9B%B8%E5%85%B3%E8%A7%84%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相关规则</h3>
<ul>
<li><a href="https://developers.weixin.qq.com/doc/oplatform/service_market/provider_guideline/audit/mini_program_develop_audit.html">小程序代开发服务上架要求</a></li>
<li><a href="https://developers.weixin.qq.com/doc/oplatform/service_market/provider_guideline/operation/mini_program_develop_operation.html">小程序代开发运营规则</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[漫谈前端项目框架搭建]]></title>
    <link href="https://www.bwrong.cn/17281470932731.html"/>
    <updated>2024-10-06T00:51:33+08:00</updated>
    <id>https://www.bwrong.cn/17281470932731.html</id>
    <content type="html"><![CDATA[
<p>前端框架搭建是每一个前端工程师都会遇到，特别是在一些小型团队内，没有专门的架构师，所以这项工作就落到一些普通的前端开发工程师手中，这时很多人可能会从网上去查找一些成熟的框架，虽然能够完成项目，但是有可能会存在一些问题：</p>
<ul>
<li>对这些框架不够了解，导致出现问题排查困难，后续升级维护困难。</li>
<li>这类框架一般具有通用属性，并不是根据项目按需搭建，导致功能冗余或者改造成本高。</li>
<li>多个项目多人负责，可能会选择不同的框架，导致标准不统一，协作困难，也难以形成团队技术沉淀。</li>
</ul>
<p>所以，框架搭建是晋升高级前端工程师的必经之路，固有必要探探其究竟。本文不会带大家从编码层面教大家如何写代码，毕竟相关的文章网上比比皆是，本文会带你搞清整个流程和其中的一些关键环节。</p>
<p><figure><img src="media/17281470932731/17281471168320.png" alt="" /></figure></p>
<h2><a id="%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>何为软件架构</h2>
<p>在开始整个流程前，我们先开了解一些何为软件架构。</p>
<blockquote>
<p><strong>软件架构</strong>是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。软件架构会包括软件组件、组件之间的关系，组件特性以及组件间关系的特性。软件架构可以和建筑物的<a href="https://www.tw.3822808.com/baike-%E5%BB%BA%E7%AD%91">架构</a>相比拟。软件架构是构建计算机软件，开发系统以及计划进行的基础，可以列出开发团队需要完成的任务。</p>
<p>----wiki百科</p>
</blockquote>
<p>简言之，软件架构这项工作的实质就是：如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间的相互通信的方式。目的是更好的对这些组件进行研发维护，可以让系统更容易理解、易于修改、方便维护、并能轻松部署。终极目标是最大化程序员的生产力，同时最小化系统的总运维成本。</p>
<p>当然，很多人可能会说：团队就我一个前端，老夫都是CV一把梭，去TM的架构，项目照样不是完成了。</p>
<p>其实，现在一些成熟的框架比如我们用的Vue，在用脚手架初始化项目后，整个项目架构已初具雏形了。所以开发一些简单的项目是没有什么问题；而且由于前段历史原因，架构这个词在前端领域可能关注度并不高。但是一些大型项目，或者你去看一些著名的开源库内部实现，就会发现，还是能看到软件架构设计的身影，比如MVC、MVVM等其实就是分层架构，重要性不言而喻。</p>
<p>由于本文主题不是讨论架构，就不再赘述，只需要明确一件事，我们搭建的框架目的是为了提升开发效率，保证开发质量。需要遵循一下几点：</p>
<ul>
<li>易用性：框架封装基础核心功能，开发功能需求时，无需关注复杂的技术架构，只需要关注业务编码工作。</li>
<li>扩展性：各系统部分间保持高内聚低耦合，提供扩展接口，在扩展新功能时，不需要对架构进行改动，新功能不对旧功能产生影响。</li>
<li>可维护性：系统划分清晰合理，代码可读性强，文档健全完善；做好规范约束手段，防止架构腐坏。</li>
</ul>
<h2><a id="%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>技术选型</h2>
<p>所谓兵马未动粮草先行，技术栈作为我们项目框架的基石，首先我们需要确定选择什么样的技术栈，这关系到后续的一系列事情。</p>
<p>前端框架搭建过程中，可以从如下几个维度做技术选型：</p>
<ul>
<li>核心：如<a href="https://cn.vuejs.org/">Vue</a>、<a href="https://reactjs.org/">React</a>等，他是我们整个技术栈的核心，一旦确定，后续其他维度都是围绕其进行选择。</li>
<li>路由：现在大部分前端应用都是单页应用，需要前端进行路由控制，所以路由一般是必不可少的。只需要在核心层生态中选择一个合适的即可。比如<a href="https://router.vuejs.org/">VueRouter</a>，<a href="https://reactrouter.com/">ReactRouter</a>。</li>
<li>视觉：主要是组件库和风格的选择，PC和移动端可能会使用不同的组件库。当然如果是做的偏前端的应用，可能现有组件库很难满足要求，目前大部分都是偏中后台的，这时可以选择自建。</li>
<li>数据：这一层不是必须的，一般只有数据交互较复杂的应用才可能会用到，而且目前Hooks也能实现一部分数据管理，只是采用专业的状态管理工具，可以保证大家在认知和实施层面的统一。当然并不绝对，在下就曾经在一个项目中使用hooks管理状态，也没有什么问题。</li>
</ul>
<pre class="line-numbers"><code class="language-typescript">/******* state *******/
const state = reactive({
});
/******* getter *******/
const getter = reactive({
});
/******* actions *******/
const actions = {
};

export const useAppStore = () =&gt; ({ state, getter, ...actions });
</code></pre>
<ul>
<li>构建工具：当下前端开发是离不开工程化的，这一领域目前正处于发展阶段，虽然各种工具层出不穷，但是各有优缺点、不统一也为开发者带来了一些困扰，但是好在，VRA都提供了自己的脚手架，大部分情况我们是可以放行使用的。当然一般成熟的团队都会在其基础上做更多的配置扩展，形成自己内部成熟的框架模板。</li>
<li>插件：现在前端的轮子是比较多的，开发的时候一般建议优先去npm看看是否有现成的轮子，不要做重复的事情。</li>
</ul>
<p><figure><img src="media/17281470932731/17281471168345.png" alt="image-20221127182555242" /><figcaption>image-20221127182555242<figcaption></figure></p>
<p>但是需要注意，npm上的包虽然多，但是质量参差不齐，可以从几个方面去筛选。</p>
<p><figure><img src="media/17281470932731/17281471168356.png" alt="image-20221127183017318" /><figcaption>image-20221127183017318<figcaption></figure></p>
<p>以上是需要进行技术选型的维度，接下来我们就看看通过哪些指标去帮我们做出抉择。</p>
<ul>
<li>选择团队掌握的技术</li>
</ul>
<p>如果选择不熟悉的技术，那么在使用过程中出现风险是不可控的。每种技术都是有它特定的适用场景，开发者经常犯的错误就是盲目追新，当一个新语言、框架、工具出现后，特别是开发者自己学会了这种新技术后，就会有种“拿着锤子找钉子”的感觉，将新技术滥用于各种项目。即使选择较新的技术，也要考虑到学习曲线和开发难度问题，主要结合当前团队的技术特点，熟练程度来考虑。</p>
<ul>
<li>保证统一性</li>
</ul>
<p>对内保持团队技术栈统一，减少因为技术不统一带来的协作维护难度；对外符合行业标准，降低招聘难度，缩短新人进入开发的时间。</p>
<ul>
<li>选择拥有强大生态和社区支撑的开源技术</li>
</ul>
<p>有强大的生态和社区意味着，很多东西你不需要重复去造轮子，或者遇到问题可以很快解决，有更多的选择。从公司层面、使用活跃的技术也比较好招人。另外在选择技术栈时要尽量避免一些公司的KPI成果，有烂尾的风险。</p>
<ul>
<li>选择成长期的技术</li>
</ul>
<p>选择一个技术的最低标准是，技术的生命周期必须显著长于项目的生命周期，好的技术栈永远跑在用户需求前面，是面向未来的。主要考量该技术今后几年是否有人维护，是否在我们项目可预见到的生命期内还能继续开发。如果它不开发了，那么遇到平台升级，遇到第三方组件升级，产生的兼容性问题就很致命。如果当前已经进入开发欠活跃阶段，就要考虑是否不予采用。</p>
<ul>
<li>学会从业务端开始思考</li>
</ul>
<p>选型需要充分地理解业务，理解用户需求，当下需要解决的首要问题，以及可能的风险有哪些，再将目标进行分解，进行具体的技术选型、模型设计、架构设计。处于初创期的业务，选型的基准是灵活。只要一个技术够用并且开发效率足够高，那么就可以选择它。初创的业务往往带有风险性和不确定性，朝令夕改、反复试错是常态，技术必须适应业务的节奏，然后才是其他方面。等业务进入稳定期，选型的基准是可靠。技术始终是业务的基石，当业务稳定了技术不稳，那就会成为业务的一块短板，就必须要修正。当业务进入维护期，选型的基准是妥协。代码永远有变乱的趋势，一般经过一两年就有必要对代码来一次大一点的重构。在这种时候，必须得正视各种遗留代码的迁移成本，如果改变技术选型会带来遗留代码重写，这背后带来的代价业务无法承受，那么我们就不得不考虑在现有技术选型之上做一些小修小补或者螺旋式上升的重构。</p>
<ul>
<li>选择API稳定的技术</li>
</ul>
<p>比较典型的例子就是Angular和Python，API不稳定会导致社区的割裂，也会导致项目升级成本变高、或者无法升级, 最终成为技术债。</p>
<p>当然，对于团队而言也要鼓励学习新的技术、淘汰旧的技术栈。因为一般而言新的技术或解决方案，是为了更高的生产力而诞生的。</p>
<ul>
<li>先验证，后使用</li>
</ul>
<p>对于未经验证的新技术、新理念的引入一定要慎重，一定要在全方位的验证过后，再大规模的使用。新技术、新理念的出现，自然有它的诱惑，慎重并不代表保守，技术总是在不断前进，拥抱变化本身没有问题，但是引入不成熟的技术看似能带来短期的收益，但是它的风险或者是后期的成本可能远远大于收益。记住，技术选型是稳定压倒一切。</p>
<ul>
<li>重视经验</li>
</ul>
<p>技术选型是个很需要经验的活，得有大量的信息积累和输入，再根据具体现实情况输出一个结果。我们在选型的时候最忌讳的是临时抱佛脚、用网上收集一些碎片知识来决策，这是非常危险的，我们得确保自己所有思考都是基于以前的事实，还要弄清楚这些事实背后的假设，这都需要让知识内化形成经验。</p>
<ul>
<li>避免法律纠纷问题</li>
</ul>
<p>选择技术时，要考虑license问题，不要陷入法律纠纷，特别是你参与的产品对外有机会做大做强、面向国际时。</p>
<p>毕竟技术只是实现业务的手段而已，我们也只是实现领导实现目标的工具而已，技术选型有时可能会受业务需求和领导个人偏好影响，不能一概而论，所以这里只是列出技术选型的注意事项，以作参考，具体选型考量还请结合实际情况而定。</p>
<p>做好了技术选型，接下来就只需要把合适的东西扔到合适的地方就行了。所以接下来我们就来看看框架设计。</p>
<h2><a id="%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>框架设计</h2>
<p>框架设计我们可以从两个层面来入手：</p>
<p>基础层：主要是从架构层面出发，包含一些基础设施，与业务相关性较低。</p>
<p>应用层：贴近业务，用于解决某一类/个业务，不同的业务可能并不能通用。</p>
<h3><a id="%E5%9F%BA%E7%A1%80%E5%B1%82%E8%AE%BE%E8%AE%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础层设计</h3>
<p>首先我们要选择一种架构风格，不同人的喜好、不同的项目会倾向不同架构风格。这里仅列出其中两种风格。</p>
<h4><a id="%E5%B7%A5%E4%BB%B6%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工件模型</h4>
<ul>
<li>描述：即按照技术工件（如components、store）职责来进行划分。</li>
<li>特点：该方式对开发人员来说易于理解，因为对他们来说技术工件比功能更有亲和力，但是相反不利于对业务功能的理解，且各功能模块间划分不太清晰，开发和维护一个功能可能要在多个目录下操作。</li>
<li>适用场景：该方式比较通用，一般的项目都会采用此方式。不过在大型项目可能会存在每个工件目录存在很多文件，且存在各个模块的文件。</li>
</ul>
<p><figure><img src="media/17281470932731/17281471168366.png" alt="image-20221127195615915" /><figcaption>image-20221127195615915<figcaption></figure></p>
<p><figure><img src="media/17281470932731/17281471168376.png" alt="image-20221127200629453" /><figcaption>image-20221127200629453<figcaption></figure></p>
<h4><a id="%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8Bhttps-medium-com-nate-wangfeature-oriented-architecture-for-web-applications-2b48e358afb0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://medium.com/@nate_wang/feature-oriented-architecture-for-web-applications-2b48e358afb0">领域模型</a></h4>
<ul>
<li>描述：按照系统功能进行划分，每个功能即为一个文件夹，其下包含自己的component、store、router。</li>
<li>特点：面向业务功能，每个功能包含自身需要的技术工件，仅对外提供一个出口服务即可，由应用整合这些服务，构成整个应用。设计偏向微服务化，开发和维护一个功能仅需关注自身的目录即可；有助于开发人员对业务的理解。</li>
<li>适用场景：特别适合大型项目、且各模块耦合度较低的场景，具有高扩展性。</li>
</ul>
<p><figure><img src="media/17281470932731/17281471168388.png" alt="image-20221127195630260" /><figcaption>image-20221127195630260<figcaption></figure></p>
<p><figure><img src="media/17281470932731/17281471168407.png" alt="图片(1)" /><figcaption>图片(1)<figcaption></figure></p>
<p>因为当前团队，基本是使用第一种风格，后续我就以此为例，在vite+vue3的基础上做叙述。首先展示一下我目前使用的项目结构设计。</p>
<pre class="line-numbers"><code class="language-js">|- docs // 文档
|- dist // 构建成果
|- mock // 数据mock
|- public  // 静态资源，会直接拷贝到dist
|- src
  |- api // api接口管理
  |- assets  // 静态资源，这里的资源会被构建工具编译
  |- components // 全局组件
  |- config // 全局配置
  |- directives // 全局指令
  |- enums // 枚举及一些常量管理
  |- hooks // 全局hooks，用于抽离公用逻辑
  |- layouts // 布局组件
  |- plugins // 第三方插件
  |- router  // 路由
  |- store   // 状态
  |- utils   // 工具函数
  |- views   // 页面
  |- App.vue  // 根组件
  |- main.ts  // 应用入口
|- types   // 类型声明
|- .browserslistrc // 浏览器兼容性配置，可以供多个工具使用
|- .editorconfig // 编辑器配置，统一不同编辑器格式
|- .env.* // 环境变量配置，建议多个环境分别使用不同的文件
|- .npmrc // 统一项目npm镜像源
|- ... // 各工具配置
|- README.md  // 说明，包含项目信息及注意事项
|- index.html // 入口页面
|- vite.config.ts // vite配置
</code></pre>
<p>这里我们可以采用在官方脚手架的基础上来完善，以后可以直接使用，或者开源到社区，供别人使用。</p>
<p>在创建Vue项目，现在推荐使用 <a href="https://github.com/vuejs/create-vue">create-vue</a>。</p>
<pre class="line-numbers"><code class="language-bash">&gt; npm init vue@latest
</code></pre>
<pre class="line-numbers"><code class="language-bash">✔ Project name: … &lt;your-project-name&gt;
✔ Add TypeScript? … No / Yes
✔ Add JSX Support? … No / Yes
✔ Add Vue Router for Single Page Application development? … No / Yes
✔ Add Pinia for state management? … No / Yes
✔ Add Vitest for Unit testing? … No / Yes
✔ Add Cypress for both Unit and End-to-End testing? … No / Yes
✔ Add ESLint for code quality? … No / Yes
✔ Add Prettier for code formatting? … No / Yes

Scaffolding project in ./&lt;your-project-name&gt;...
Done.
</code></pre>
<p>由于脚手架创建的工程已包含基础层需要的大部分功能，在此基础上可根据需求引入如下功能即可：</p>
<ul>
<li>UI组件库：建议尽量采用按需加载方式，目前大部分组件库都支持使用<a href="https://github.com/antfu/unplugin-vue-components">unplugin-vue-components</a>做自动按需引入，比较舒服。</li>
<li>各编译语言：由于html+css+js自身能力局限，我们可以使用一些编译语言来提升开发效率，如less、typescript等等。</li>
</ul>
<p>因为类似的文章网上也比较多写的也比较好，这里就不再赘述。</p>
<p><a href="https://juejin.cn/post/7079785777692934174">手把手教你用 vite + vue3 + ts + pinia + vueuse 打造企业级前端项目</a></p>
<h3><a id="%E5%BA%94%E7%94%A8%E5%B1%82%E8%AE%BE%E8%AE%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用层设计</h3>
<p>由于应用层需要结合具体业务情况，这里我就仅谈谈在我开发过程中两个比较常用的功能：</p>
<h4><a id="%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>权限控制</h4>
<p>一般中后台项目都有权限控制这部分功能，这里前端需要关心的主要是两方面：</p>
<h5><a id="%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>登录认证</h5>
<p>这个好理解，只有你登录了，系统才知道你是谁，我们要做的也很简单，只需要登录成功后把后端返回的令牌存储到本地，然后后续每次请求带上该信息，后端去做验证，如果验证通过返回200，不通过返回401，直接踢回登录页或者给出提示，另外在路由全局前置守卫也可以做判断。</p>
<p>实现方案我这里就不献丑了，贴上两篇写的很好的文章：</p>
<p><a href="https://juejin.cn/post/6898630134530752520">前端鉴权的兄弟们：cookie、session、token、jwt、单点登录</a></p>
<p><a href="https://juejin.cn/post/7129298214959710244">一文教你搞定所有前端鉴权与后端鉴权方案，让你不再迷惘</a></p>
<p>下面贴下代码：</p>
<ul>
<li>登录保存认证信息，我这里是token、refreshToken、tokenExpires，需要保存到本地缓存。</li>
</ul>
<p><figure><img src="media/17281470932731/17281471168422.png" alt="image-20221128114406893" /><figcaption>image-20221128114406893<figcaption></figure></p>
<ul>
<li>
<p>请求拦截器注入认证信息，需要根据后端要求去注入，一般都是在header中。</p>
<p><figure><img src="media/17281470932731/17281471168435.png" alt="image-20221128114724023" /><figcaption>image-20221128114724023<figcaption></figure></p>
</li>
</ul>
<p>​		这里有个handleCheckAuth，是做了静默token刷新功能，在token要到期前，使用refreshToken去后台换去新的token，代码如下：</p>
<pre class="line-numbers"><code class="language-ts">/**
 * 刷新token
 * @param {string} refreshToken
 */
export const handleRefreshToken: {
  (token: string | undefined): void;
  refreshDoing?: boolean;
} = (refreshToken) =&gt; {
  if (handleRefreshToken.refreshDoing) return;
  handleRefreshToken.refreshDoing = true; // 加锁，防止重复刷新
  auth
    .refreshToken({ refresh_token: refreshToken })
    .then((res) =&gt; saveAuthData(res))
    .finally(() =&gt; {
      handleRefreshToken.refreshDoing = false;
    });
};
/**
 * 检查更新token
 * @param config
 */
export function handleCheckAuth(config: AxiosRequestConfig) {
  const tokenExpires = Cookie.get(tokenExpiresKey);
  if (Number(tokenExpires) &lt;= Date.now() &amp;&amp; !config.skipCheckAuth) {
    handleRefreshToken(Cookie.get(refreshTokenKey));
  }
}
</code></pre>
<ul>
<li>路由拦截，看注释吧</li>
</ul>
<p><figure><img src="media/17281470932731/17281471168448.png" alt="image-20221128115106273" /><figcaption>image-20221128115106273<figcaption></figure></p>
<h5><a id="%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>权限控制</h5>
<p>所谓权限控制，就是针对不同的用户赋予不同的权限，对应到前端就是根据不同权限的人动态控制呈现不同的资源，这里资源是一个统称，包含页面、按钮、数据等等，比如超管和管理员进入系统看到的菜单和页面中的按钮不一致。</p>
<p>关于系统权限控制如何设计，主要和业务需求有关系，这里我们不去深究，只是了解一下目前比较流行的一种权限模型。</p>
<p>RBAC（基于角色的权限控制）模型的核心是在用户和权限之间引入了角色的概念。取消了用户和权限的直接关联，改为<strong>通过用户关联角色、角色关联权限的方法来间接地赋予用户权限</strong>（如下图），从而达到用户和权限解耦的目的。比如在创建多个权限相同的用户，我们不需要给每个人单独设置权限，只需要将他们赋予相同的角色即可。</p>
<p><figure><img src="media/17281470932731/17281471168461.png" alt="img" /><figcaption>img<figcaption></figure></p>
<p>目前我们大部分系统都是使用该模型，下面我们也就基于该模型来看看前端如何进行权限控制。</p>
<p>其实现在网上讲前端权限控制的文章有很多，总结起来大体思路是，登录成功后获取用户当前的权限数据，然后动态添加路由，生成菜单，页内元素可以通过指令或者vif实现控制。实现方案上有如下两个流派：</p>
<h6><a id="%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前端控制</h6>
<p>整个动态路由表是放在前端，每个路由通过meta.role设置允许访问的角色，登录后后台返回当前用户的role标识信息，前端根据这个role去和路由的meta.role做匹配，清洗出匹配的路由，然后动态注册仅路由。由于只是返回了role信息，所以菜单是需要后端另外提供的。</p>
<pre class="line-numbers"><code class="language-js">// asyncRoutes 动态路由表
export const asyncRoutes = [
  {
    path: '/permission',
    component: Layout,
    redirect: '/permission/page',
    alwaysShow: true, 
    name: 'Permission',
    meta: {
      title: 'Permission',
      icon: 'lock',
      // admin、editor可以查看该路由
      roles: ['admin', 'editor']
    },
    children: [
      {
        path: 'page',
        component: () =&gt; import('@/views/permission/page'),
        name: 'PagePermission',
        meta: {
          title: 'Page Permission',
          // admin可以查看该路由
          roles: ['admin']
        }
      }
     ]
    }
]
</code></pre>
<pre class="line-numbers"><code class="language-js">// 这个方法是用来把角色和route.meta.role来进行匹配
function hasPermission(roles, route) {
  if (route.meta &amp;&amp; route.meta.roles) {
    return roles.some(role =&gt; route.meta.roles.includes(role))
  } else {
    return true
  }
}


// 这个方法是通过递归来遍历路由，把有权限的路由给遍历出来
export function filterAsyncRoutes(routes, roles) {
  const res = []
  routes.forEach(route =&gt; {
    const tmp = { ...route }
    if (hasPermission(roles, tmp)) {
      if (tmp.children) {
        tmp.children = filterAsyncRoutes(tmp.children, roles)
      }
      res.push(tmp)
    }
  })
  return res
}
</code></pre>
<p>除了上述说的后端返回role标识，还有一种变种大家可以查看该文章<a href="https://refined-x.com/2017/11/28/Vue2.0%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6">Vue2.0用户权限控制解决方案/#路由控制</a>。</p>
<p>前端控制的特点如下：</p>
<ul>
<li>路由表在前端维护，变动比较方便，对前端比较友好。</li>
<li>实现逻辑比较简单，上手难度低。</li>
<li>后期修改角色权限难度较大，需要修改前端代码，不支持在后台系统中动态配置角色权限。</li>
</ul>
<h6><a id="%E5%90%8E%E7%AB%AF%E6%8E%A7%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>后端控制</h6>
<p>接下来看看后端控制，主要区别就是把路由表挪到了后端，前端可以直接或简单转换使用后端返回的路由表数据注册路由，一般这份数据是可以直接生成菜单数据的，固不需要再单独返回菜单信息。</p>
<p><figure><img src="media/17281470932731/17281471168473.png" alt="image-20221128160927872" /><figcaption>image-20221128160927872<figcaption></figure></p>
<p>该方案的特点如下：</p>
<ul>
<li>可以在后台动态配置，可以实现角色权限灵活配置。下图是之前做过的系统，整个菜单树都可以在后台灵活组装，灵活度很高。</li>
</ul>
<p><figure><img src="media/17281470932731/17281471168487.png" alt="image-20221128163522794" /><figcaption>image-20221128163522794<figcaption></figure></p>
<ul>
<li>前端实现比较简单，不用自己维护路由表。</li>
<li>由于前端不自己维护路由表，那么要调整路由必须就得去后台，比如每开发一个新页面就需要去后台配置对应的菜单路由信息，而且还必须和前端对应起来。</li>
<li>前后端划分的方式可能有差异，比如某个列表页每条数据的查看详情是新开页面，在后端看来详情亦属于查看，如果能够查看列表肯定就能查看详情，不需要单独配置菜单，但是因为是新开页面，前端就需要一个新的路由，即使能够单独创建一个详情的权限，在后端的划分中，详情应该是属于这个列表页的下级，但是在前端可能需要的是同级，而不是嵌套在列表页路由的children中。</li>
</ul>
<h6><a id="%E6%94%B9%E8%89%AF%E4%B8%80%E4%B8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>改良一下</h6>
<p>我们可以看到如上两种方案都不是完美的，所以我在项目中采用了另外的方式，基于后端控制做了改良。思路如下：</p>
<ol>
<li>
<p>后台菜单配置时，不再配置url和组件相关信息，毕竟这部分内容是前端路由使用的，前端控制更加合适，也方便前端做调整。然后仅需要填写一个权限表示码就行，降低了前后端数据的耦合性，也就不存在划分不一致带来的问题了。</p>
<p><figure><img src="media/17281470932731/17281471168502.png" alt="image-20221128171252175" /><figcaption>image-20221128171252175<figcaption></figure></p>
</li>
<li>
<p>后台给角色设置拥有的菜单、按钮等资源的权限。</p>
<p><figure><img src="media/17281470932731/17281471168517.png" alt="image-20221128171444752" /><figcaption>image-20221128171444752<figcaption></figure></p>
</li>
<li>
<p>前端维护路由表，和正常路由差不多，但是不用默认注册，而且需要控制的路由要有meta.permission，和前面后台设置的权限标识码对应就行。如果没有permission标识，可以保留或者舍弃，这个根据需求来决定使用哪种方式，我采用的是保留。比如上面我们说的查看详情那里，我就可以不设置permission，这样只要用户有当前菜单的权限（即列表页），那么就不用再设置查看详情的权限了。</p>
<pre class="line-numbers"><code class="language-json"> {
    path: '/system',
    name: 'system',
    redirect: '/system/department',
    meta: {
      permission: 'system' // 权限标识码
    },
    children: [
      {
        path: '/system/role',
        name: 'role',
        component: () =&gt; import('@/views/system/Role.vue'),
        meta: {
          permission: 'system/role'
        }
      }
   ]
}
</code></pre>
</li>
<li>
<p>前端登录成功以后，后端提供如下菜单数据。</p>
</li>
</ol>
<pre class="line-numbers"><code class="language-json">[
  {
    &quot;id&quot;: 1,
    &quot;permission&quot;: &quot;system&quot;, // 前面填写的权限标识码
    &quot;name&quot;: &quot;系统管理&quot;,
    &quot;type&quot;: 0,
    &quot;parentId&quot;: 0
  },
  {
    &quot;id&quot;: 2,
    &quot;permission&quot;: &quot;system/role&quot;,
    &quot;name&quot;: &quot;角色管理&quot;,
    &quot;type&quot;: 0,
    &quot;parentId&quot;: 1
  },

  {
    &quot;id&quot;: 3,
    &quot;permission&quot;: &quot;system/menu&quot;,
    &quot;name&quot;: &quot;菜单管理&quot;,
    &quot;type&quot;: 0,
    &quot;parentId&quot;: 1
  },
  {
    &quot;id&quot;: 4,
    &quot;permission&quot;: &quot;user&quot;,
    &quot;name&quot;: &quot;用户管理&quot;,
    &quot;type&quot;: 0,
    &quot;parentId&quot;: 0
  },
  // ....
]
</code></pre>
<ol start="5">
<li>
<p>通过将菜单表和路由表通过permission权限标识码进行匹配，做数据处理。这里数据处理可能比较复杂一点，需要输出两份数据</p>
<ul>
<li>
<p>路由：根据菜单的permission，将路由表中的数据做清洗，去掉permission在菜单中没有的路由。另外一点就是把菜单数据添加到路由的meta中，主要为了方便通过当前路由获取当前的菜单信息。这个数据用于注册动态路由。</p>
<pre class="line-numbers"><code class="language-json">{
    &quot;path&quot;: &quot;/system&quot;,
    &quot;name&quot;: &quot;system&quot;,
    &quot;redirect&quot;: &quot;/system/config&quot;,
    &quot;meta&quot;: {
        &quot;permission&quot;: &quot;system&quot;,
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;系统管理&quot;,
        &quot;type&quot;: 0,
        &quot;priority&quot;: 0,
        &quot;icon&quot;: &quot;icon-setting&quot;,
        &quot;parentId&quot;: 0
    },
    &quot;children&quot;: [
        {
            &quot;path&quot;: &quot;/system/config&quot;,
            &quot;name&quot;: &quot;config&quot;,
            &quot;meta&quot;: {
                &quot;permission&quot;: &quot;system/config&quot;,
                &quot;id&quot;: 2,
                &quot;title&quot;: &quot;系统配置&quot;,
                &quot;type&quot;: 0,
                &quot;priority&quot;: 0,
                &quot;icon&quot;: &quot;icon-setting&quot;,
                &quot;parentId&quot;: 1
            }
        },
        ...
    ]
}
</code></pre>
</li>
<li>
<p>菜单：因为现在菜单设置没有设置url了，所以我们要通过permission去找到对应的路由，然后将其path作为url。该数据用于显示导航菜单。</p>
<pre class="line-numbers"><code class="language-json">[{
    &quot;id&quot;: 1,
    &quot;permission&quot;: &quot;system&quot;,
    &quot;title&quot;: &quot;系统管理&quot;,
    &quot;type&quot;: 0,
    &quot;priority&quot;: 0,
    &quot;icon&quot;: &quot;icon-setting&quot;,
    &quot;parentId&quot;: 0,
    &quot;url&quot;: &quot;/system&quot;
},{
    &quot;id&quot;: 2,
    &quot;permission&quot;: &quot;system/config&quot;,
    &quot;title&quot;: &quot;系统配置&quot;,
    &quot;type&quot;: 0,
    &quot;priority&quot;: 0,
    &quot;icon&quot;: &quot;icon-setting&quot;,
    &quot;parentId&quot;: 1,
    &quot;url&quot;: &quot;/system/config&quot;
}]
</code></pre>
</li>
</ul>
</li>
</ol>
<p><figure><img src="media/17281470932731/17281471168530.png" alt="image-20221128172904940" /><figcaption>image-20221128172904940<figcaption></figure></p>
<p>该方案的特点是：</p>
<ul>
<li>前后端解耦，上帝的归上帝,凯撒的归凯撒，而且仅需保证permission对应就行。</li>
<li>菜单表和路由表进行匹配处理的时候，算法复杂一点。</li>
</ul>
<p>基于该套方案，我这边进行了封装，可以直接进行使用<a href="https://github.com/BWrong/auth-tool.git">auth-tool</a>。</p>
<p><strong>注意：</strong></p>
<ul>
<li>路由控制这一步不能少，否则即使菜单没有入口了，但是用户通过输入url地址还是能访问无权限的页面。路由控制除了动态路由还有一种方案就是全量注册路由，然后在前置守卫每次跳转去做验证判断，没权限重定向到403页面。</li>
<li>前端做权限控制只是锦上添花，不是绝对安全，一定需要后端做验证来兜底，后端需要对每一个涉及请求的操作做验证。</li>
</ul>
<p>另外简单说一说页内元素的控制吧，其实比较简单，后端同样返回有权限的数据，前端通过自定义指令或者Vif做下判断就行。<a href="https://github.com/BWrong/auth-tool.git">auth-tool</a>也做了封装，需要的自己查看源码吧。</p>
<pre class="line-numbers"><code class="language-typescript">Vue.directive(directiveName, {
  mounted(el:Element, binding) {
    !hasAuth(binding.value) &amp;&amp; el.parentNode?.removeChild(el);
  }
});
</code></pre>
<h4><a id="%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据请求</h4>
<p>另外一个比较重要的功能就是请求的封装了，其实axios本身还是比较成熟了，之所以要把这个单独拿出来说，主要是之前在项目上遇到过一些问题。</p>
<ul>
<li>
<p>请求建议集中管理，可以按照业务进行模块划分，页面中只需要调用这里提供的方法就行。不建议直接写在页面上，不方便维护，万一接口url做了调整，你都不知道那些页面使用了，只有全局去替换。</p>
<p><figure><img src="media/17281470932731/17281471168544.png" alt="image-20221128180115019" /><figcaption>image-20221128180115019<figcaption></figure></p>
</li>
</ul>
<pre class="line-numbers"><code class="language-typescript">import { get } from '../../utils/request';
import type { RequestConfig } from '@/utils/request/Request';
const prefix = '/system/config';
export default { list: &lt;T = any&gt;(params: object, config?: RequestConfig) =&gt; get&lt;T&gt;(`${prefix}`, params, config) };
</code></pre>
<ul>
<li>如果存在多个服务器，而且配置可能有差异的时候，建议对axios进行类封装，不同的服务器使用不同的实例。同样贴上两篇优秀的文章
<ul>
<li><a href="https://juejin.cn/post/7124573626161954823">前端架构带你 封装axios，一次封装终身受益</a></li>
<li><a href="https://juejin.cn/post/7071518211392405541">在项目中用ts封装axios，一次封装整个团队受益</a></li>
</ul>
</li>
</ul>
<p>我在项目中也封装了一个，展示还没有单独提取出来，有兴趣的可以看看<a href="https://cdn.jsdelivr.net/gh/BWrong/Pictures@master/uPic/20221128181306.ts">这里</a></p>
<pre class="line-numbers"><code class="language-plain_text">   * 1. 多实例，在存在多个请求服务时使用
   * 2. 拦截器增强，支持全局拦截器和实例拦截器，执行顺序采用洋葱模型
   * 3. 支持重复请求取消功能，重复请求：url、method、参数均一致为重复，也可以自己传入判断函数
   * 4. 支持直接请求绝对地址
   * 5. ts类型推断增强，更好的类型提示
</code></pre>
<h2><a id="%E5%85%B6%E4%BB%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他</h2>
<h4><a id="%E8%A7%84%E8%8C%83%E7%BA%A6%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>规范约定</h4>
<p>如果项目中存在多人开发，那么规范和约定就必不可少，除了我们要形成团队的一些规范文档外，在框架上我们也可以通过工程化去约束：</p>
<ul>
<li>使用eslint，如果团队有统一的规范，建议直接发布为rule插件。</li>
<li>使用githooks做提交前的验证，当然最保险的还是在流水线去做这个事情，毕竟本地是可以绕过的。</li>
</ul>
<pre class="line-numbers"><code class="language-json">&quot;gitHooks&quot;: {
    &quot;pre-commit&quot;: &quot;lint-staged --allow-empty&quot;
  },
  &quot;lint-staged&quot;: {
    &quot;*.{vue,js,jsx,cjs,mjs,ts,tsx}&quot;: [
      &quot;npm run lint&quot;,
      &quot;prettier --write&quot;
    ],
    &quot;*.{css,less}&quot;: [
      &quot;npm run lint:style&quot;,
      &quot;prettier --write&quot;
    ]
  }
</code></pre>
<h4><a id="%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>版本管理</h4>
<p>关于版本管理这块，我之前遇到过得问题就是给多个用户部署不同的版本，但是当某个用户出问题时，不能第一时间知道该用户部署的代码是什么时候的。所以后来在构建时注入了相关信息。</p>
<pre class="line-numbers"><code class="language-ts">import { GitRevisionPlugin } from 'git-revision-webpack-plugin';
import pkg from './package.json';
let appVersion = `app-version=${pkg.version},build-time=${new Date().toLocaleString()}`;
  if (IS_PRODUCTION) {
    try {
      const GitRevision = new GitRevisionPlugin();
      appVersion += `,git-hash=${GitRevision.version()},git-branch=${GitRevision.branch()}`;
    } catch (error) {
      console.warn('无法获取git信息,无法注入相关内容!');
    }
  }
  
  ...
   createHtmlPlugin({
        minify: true,
        entry: '/src/main.ts',
        // template: 'index.html',
        inject: {
          data: {
            BASE_URL: VITE_BASE_URL,
            title: VITE_TITLE,
            appVersion
          }
        }
      }),
</code></pre>
<p><figure><img src="media/17281470932731/17281471168559.png" alt="image-20221128182524845" /><figcaption>image-20221128182524845<figcaption></figure></p>
<p>然后关于更新日志和版本发布，可以使用<a href="https://github.com/release-it/release-it">release-it</a>或<a href="https://github.com/conventional-changelog/standard-version#readme">standard-version</a>去做。</p>
<h4><a id="%E6%9E%84%E5%BB%BA%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>构建优化</h4>
<p>优化主要是两个方向：</p>
<ul>
<li>运行时：提升程序运行效率，就是常规的性能优化手段都可以用上，比如gzip、分包、按需加载等等。</li>
<li>开发时：主要是加快构建速度，提升开发效率，有几个思路可以考虑，减少构建的范围、利用缓存、使用多进程。</li>
</ul>
<h4><a id="%E8%84%9A%E6%89%8B%E6%9E%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>脚手架</h4>
<p>当你的框架成熟后，可以自己封装一个脚手架，可以做一些定制化的配置，这个比较简单，感兴趣的查看<a href="https://juejin.cn/post/6924205809349951501">用vue3+ts+electron撸了一个好用的脚手架工具</a>，这样团队成员使用起来就比较方便，也比较好管理。</p>
<h2><a id="%E7%BB%93%E8%AF%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结语</h2>
<p>算了，下班了，没时间写了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScript --- 进阶篇]]></title>
    <link href="https://www.bwrong.cn/17280550301505.html"/>
    <updated>2024-10-04T23:17:10+08:00</updated>
    <id>https://www.bwrong.cn/17280550301505.html</id>
    <content type="html"><![CDATA[
<h3><a id="%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型别名</h3>
<p>简单来讲，类型别名就是给一个类型起一个新名字。</p>
<p>简单的例子：</p>
<pre class="line-numbers"><code class="language-plain_text">type Name = string
type NameResolver = () =&gt; string
type NameOrResolver = Name | NameResolver
function getName(n: NameOrResolver): Name {
	if (typeof n === 'string') {
        return n;
    } else {
        return n();
    }
}
</code></pre>
<p>上例中，我们使用 <code>type</code> 创建类型别名。</p>
<p>类型别名常用于联合类型。</p>
<h4><a id="%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型别名与接口的区别</h4>
<p>类型别名与接口非常相似，他们两者可以相互选择</p>
<pre class="line-numbers"><code class="language-plain_text">interface Person {                
	name: string;
	age: number
}
type Person = {
	name: string;
	age: number
}
</code></pre>
<h5><a id="%E5%90%8C%E5%90%8D%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%90%88%E5%B9%B6%EF%BC%8C%E8%80%8C%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E4%B8%8D%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>同名接口定义的类型可以合并，而类型声明不行</h5>
<pre class="line-numbers"><code class="language-plain_text">interface Person {
	name: string;
}
interface Person {
	age: number
}
const person: Person = {
	name: 'xiaohong',
	age: 18
}
</code></pre>
<table>
<thead>
<tr>
<th style="text-align: center">Type</th>
<th style="text-align: center">interface</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">只能通过&amp;进行合并</td>
<td style="text-align: center">同名自动合并，通过extends扩展</td>
</tr>
<tr>
<td style="text-align: center">更强大，除了以上类型还支持 string 数组...</td>
<td style="text-align: center">自身只能表达 object/class/function类型</td>
</tr>
</tbody>
</table>
<p>建议：能用 interface 实现，就用 interface , 如果不能才用 type</p>
<h3><a id="%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字面量类型</h3>
<p>字符串字面量类型用来约束取值只能是某几个字符串的一个。</p>
<p>例子：</p>
<pre class="line-numbers"><code class="language-plain_text">tyep EventNames = 'click' | 'scroll' | 'mouseove'
function handleEvent(ele: Element, event: EventNames) {
	// todo
}
andleEvent(document.getElementById('hello'), 'scroll');  // 没问题
handleEvent(document.getElementById('world'), 'dblclick'); // 报错，event 不能为 'dblclick'
</code></pre>
<p>上例中，我们使用 <code>type</code> 定了一个字符串字面量类型 <code>EventNames</code>，它只能取三种字符串中的一种。</p>
<p>除了字符串字面量类型之外，TypeScript 同样也提供 <code>boolean</code> 和 <code>number</code> 的字面量类型：</p>
<pre class="line-numbers"><code class="language-plain_text">type OneToFive = 1 | 2 | 3 | 4 | 5;
type Bools = true | false;
</code></pre>
<p>注意，<strong>类型别名与字符串字面量类型都是使用 <code>type</code> 进行定义。</strong></p>
<h3><a id="%E5%85%83%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>元组</h3>
<p>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。</p>
<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。</p>
<p>元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。</p>
<p>简单的例子：</p>
<p>定义一对值分别为<code>string</code>和<code>number</code>的元组</p>
<pre class="line-numbers"><code class="language-plain_text">let tom: [string, number] = ['Tom', 25]
</code></pre>
<p>当赋值或访问一个已知索引的元素时，会得到正确的类型：</p>
<pre class="line-numbers"><code class="language-plain_text">let tom:[string, number]
tom[0] = 'Tom'
tom[1] = 25

tom[0].slice(1)
tom[1].fixed(2)
</code></pre>
<p>也可以赋值其中一项：</p>
<pre class="line-numbers"><code class="language-plain_text">let tom = [string, number]
tom[0] = 'tom'
</code></pre>
<p>但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元素类型中指定的项。</p>
<pre class="line-numbers"><code class="language-plain_text">let tom: [string, number]
tom = ['Tom', 25]
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">let tom: [string, number]
tom = ['25']
// Property '1' is missing in type '[string]' but required in type '[string, number]'
</code></pre>
<h4><a id="%E8%B6%8A%E7%95%8C%E7%9A%84%E5%85%83%E7%B4%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>越界的元素</h4>
<p>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：</p>
<pre class="line-numbers"><code class="language-plain_text">let tom: [string, number];
tom = ['Tom', 25];
tom.push('male');
tom.push(true);

// Argument of type 'true' is not assignable to parameter of type 'string | number'.
</code></pre>
<h3><a id="%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>枚举</h3>
<p>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p>
<h4><a id="%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简单的例子</h4>
<p>枚举使用 <code>enum</code> 关键字来定义：</p>
<pre class="line-numbers"><code class="language-plain_text">enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat}
</code></pre>
<p>枚举成员会被赋值为从 <code>0</code> 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：</p>
<pre class="line-numbers"><code class="language-plain_text">enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};

console.log(Days[&quot;Sun&quot;] === 0); // true
console.log(Days[&quot;Mon&quot;] === 1); // true
console.log(Days[&quot;Tue&quot;] === 2); // true
console.log(Days[&quot;Sat&quot;] === 6); // true

console.log(Days[0] === &quot;Sun&quot;); // true
console.log(Days[1] === &quot;Mon&quot;); // true
console.log(Days[2] === &quot;Tue&quot;); // true
console.log(Days[6] === &quot;Sat&quot;); // true
</code></pre>
<h4><a id="%E6%89%8B%E5%8A%A8%E8%B5%8B%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>手动赋值</h4>
<p>我们也可以给枚举项手动赋值：</p>
<pre class="line-numbers"><code class="language-plain_text">enum Days {Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat}
console.log(Days[&quot;Sun&quot;] === 3); // true
console.log(Days[&quot;Wed&quot;] === 3); // true
console.log(Days[3] === &quot;Sun&quot;); // false
console.log(Days[3] === &quot;Wed&quot;); // true
</code></pre>
<p>上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增。</p>
<p>如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的：</p>
<pre class="line-numbers"><code class="language-plain_text">enum Days {Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat};

console.log(Days[&quot;Sun&quot;] === 3); // true
console.log(Days[&quot;Wed&quot;] === 3); // true
console.log(Days[3] === &quot;Sun&quot;); // false
console.log(Days[3] === &quot;Wed&quot;); // true
</code></pre>
<p>所以使用的时候需要注意，最好不要出现这种覆盖的情况。</p>
<p>手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的)：</p>
<pre class="line-numbers"><code class="language-plain_text">enum Days {Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = &lt;any&gt;&quot;S&quot;};
类型的断言  值 as 类型 |  或者&lt;类型&gt;值
</code></pre>
<p>当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 <code>1</code>：</p>
<h4><a id="%E5%B8%B8%E6%95%B0%E9%A1%B9%E5%92%8C%E8%AE%A1%E7%AE%97%E6%89%80%E5%BE%97%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常数项和计算所得项</h4>
<p>枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。</p>
<p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p>
<pre class="line-numbers"><code class="language-plain_text">enum Color {Red, Green, Blue = 'blue'.length}
</code></pre>
<p>上面的例子中，<code>&quot;blue&quot;.length</code> 就是一个计算所得项。</p>
<p>上面的例子不会报错，但是<strong>如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</strong>：</p>
<pre class="line-numbers"><code class="language-plain_text">enum Color {Red = &quot;red&quot;.length, Green, Blue};

// error TS1061: Enum member must have initializer.
// error TS1061: Enum member must have initializer.
</code></pre>
<p>下面是常数项和计算所得项的完整定义，部分引用自<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Enums.html">中文手册 - 枚举</a>：</p>
<p>当满足以下条件时，枚举成员被当作是常数：</p>
<ul>
<li>不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 <code>1</code>。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 <code>0</code>。</li>
<li>枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：
<ul>
<li>数字字面量</li>
<li>引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用</li>
<li>带括号的常数枚举表达式</li>
<li><code>+</code>, <code>-</code>, <code>~</code> 一元运算符应用于常数枚举表达式</li>
<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code> 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错</li>
</ul>
</li>
</ul>
<p>所有其它情况的枚举成员被当作是需要计算得出的值。</p>
<h4><a id="%E5%B8%B8%E6%95%B0%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常数枚举</h4>
<p>常数枚举是使用 <code>const enum</code> 定义的枚举类型：</p>
<pre class="line-numbers"><code class="language-plain_text">const enum Directions {
    Up,
    Down,
    Left,
    Right
}

let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];
</code></pre>
<p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</p>
<p>上例的编译结果是：</p>
<pre class="line-numbers"><code class="language-js">var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];
</code></pre>
<p>假如包含了计算成员，则会在编译阶段报错：</p>
<pre class="line-numbers"><code class="language-plain_text">const enum Color {Red, Green, Blue = &quot;blue&quot;.length};

// error TS2474: In 'const' enum declarations member initializer must be constant expression.
</code></pre>
<h4><a id="%E5%A4%96%E9%83%A8%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>外部枚举</h4>
<p>外部枚举（Ambient Enums）是使用 <code>declare enum</code> 定义的枚举类型：</p>
<pre class="line-numbers"><code class="language-plain_text">declare enum Directions {
    Up,
    Down,
    Left,
    Right
}
</code></pre>
<pre class="line-numbers"><code class="language-ts">let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];
</code></pre>
<p>之前提到过，<code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除。</p>
<p>上例的编译结果是：</p>
<pre class="line-numbers"><code class="language-plain_text">var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];
</code></pre>
<p>外部枚举与声明语句一样，常出现在声明文件中。</p>
<p>同时使用 <code>declare</code> 和 <code>const</code> 也是可以的：</p>
<pre class="line-numbers"><code class="language-plain_text">declare const enum Directions {
    Up,
    Down,
    Left,
    Right
}

let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];
</code></pre>
<p>编译结果：</p>
<pre class="line-numbers"><code class="language-plain_text">var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];
</code></pre>
<h3><a id="%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>交叉类型</h3>
<p>交叉类型是将多个类型合并为一个类型</p>
<pre class="line-numbers"><code class="language-plain_text">interface A {
	name: string;
	age: number
}
interface B {
	email: string
}
type C = A &amp; B
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">interface A {
	name: string;
	age: number
}
interface B {
	name: string;
	email: string
}
type C = A &amp; B
const c : C = {
	name: 'XXX',
	age: 18,
	email: 'xxxxxx'
}
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">type A = string | number
type B = string | boolean
type C = A &amp; B
</code></pre>
<h3><a id="%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型守卫/类型保护</h3>
<p>联合类型让一个值可以为不同的类型，但随之带来的问题就是访问非共同方法时会报错。那么该如何区分值的具体类型，以及如何访问共有成员？</p>
<h4><a id="typeof" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>typeof</h4>
<pre class="line-numbers"><code class="language-plain_text">function doSome(x: number | string) {
  if (typeof x === 'string') {
    // 在这个块中，TypeScript 知道 `x` 的类型必须是 `string`
    console.log(x.substr(1)); // ok
  }

  x.substr(1); // Error: 无法保证 `x` 是 `string` 类型
}
</code></pre>
<h4><a id="instanceof" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>instanceof</h4>
<pre class="line-numbers"><code class="language-plain_text">class Foo {
  foo = 123;
  common = '123';
}

class Bar {
  bar = 123;
  common = '123';
}

function doStuff(arg: Foo | Bar) {
  if (arg instanceof Foo) {
    console.log(arg.foo); // ok
    console.log(arg.bar); // Error
  }
  if (arg instanceof Bar) {
    console.log(arg.foo); // Error
    console.log(arg.bar); // ok
  }
}

doStuff(new Foo());
doStuff(new Bar());
</code></pre>
<h4><a id="in" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>in</h4>
<p><code>in</code> 操作符可以安全的检查一个对象上是否存在一个属性，它通常也被作为类型保护使用：</p>
<pre class="line-numbers"><code class="language-plain_text">interface A {
  x: number;
}

interface B {
  y: string;
}

function doStuff(q: A | B) {
  if ('x' in q) {
    // q: A
  } else {
    // q: B
  }
}
</code></pre>
<h4><a id="%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字面量类型保护</h4>
<p>当你在联合类型里使用字面量类型时，你可以检查它们是否有区别：</p>
<pre class="line-numbers"><code class="language-plain_text">type Foo = {
  kind: 'foo'; // 字面量类型
  foo: number;
};

type Bar = {
  kind: 'bar'; // 字面量类型
  bar: number;
};

function doStuff(arg: Foo | Bar) {
  if (arg.kind === 'foo') {
    console.log(arg.foo); // ok
    console.log(arg.bar); // Error
  } else {
    // 一定是 Bar
    console.log(arg.foo); // Error
    console.log(arg.bar); // ok
  }
}
</code></pre>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义类型保护类型</h4>
<p>函数中使用 is 定位类型，这仅仅是一个返回值为类似于<code>someArgumentName is SomeType</code> 的函数</p>
<pre class="line-numbers"><code class="language-plain_text">// 仅仅是一个 interface
interface Foo {
  foo: number;
  common: string;
}

interface Bar {
  bar: number;
  common: string;
}

// 用户自己定义的类型保护！
function isFoo(arg: Foo | Bar): arg is Foo {
  return (arg as Foo).foo !== undefined;
}

// 用户自己定义的类型保护使用用例：
function doStuff(arg: Foo | Bar) {
  if (isFoo(arg)) {
    console.log(arg.foo); // ok
    console.log(arg.bar); // Error
  } else {
    console.log(arg.foo); // Error
    console.log(arg.bar); // ok
  }
}

doStuff({ foo: 123, common: '123' });
doStuff({ bar: 123, common: '123' });
</code></pre>
<h3><a id="%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类</h3>
<p>传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 <code>class</code>。</p>
<p>TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p>
<p>这一节主要介绍类的用法，下一节再介绍如何定义类的类型。</p>
<h4><a id="%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类的概念</h4>
<p>虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。</p>
<ul>
<li>类（Class）：定义了一件事物的抽象特点，包含它的属性和方法</li>
<li>对象（Object）：类的实例，通过 <code>new</code> 生成</li>
<li>面向对象（OOP）的三大特性：封装、继承、多态</li>
<li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li>
<li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>
<li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 <code>Cat</code> 和 <code>Dog</code> 都继承自 <code>Animal</code>，但是分别实现了自己的 <code>eat</code> 方法。此时针对某一个实例，我们无需了解它是 <code>Cat</code> 还是 <code>Dog</code>，就可以直接调用 <code>eat</code> 方法，程序会自动判断出来应该如何执行 <code>eat</code></li>
<li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li>
<li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 <code>public</code>表示公有属性或方法</li>
<li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>
<li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li>
</ul>
<h4><a id="es6%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ES6中类的用法</h4>
<h5><a id="%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>属性和方法</h5>
<p>使用<code>class</code>定义类，使用<code>constructor</code>定义构造函数</p>
<p>通过<code>new</code>生成新实例的时候，会自动调用构造函数</p>
<pre class="line-numbers"><code class="language-plain_text">class Animal {
	public name;
	constructor(name) {
		this.name = name
	}
	sayHi() {
		return `My name is ${this.name}`;
	}
}
let a = new Animal('Jack')
console.log(a.sayHi()); // My name is Jack
</code></pre>
<h5><a id="%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类的继承</h5>
<p>使用<code>extends</code>关键字实现继承，子类中使用super关键字来调用父类的构造函数和方法</p>
<pre class="line-numbers"><code class="language-plain_text">class Cat extends Animal {
  constructor(name) {
    super(name); // 调用父类的 constructor(name)
    console.log(this.name);
  }
  sayHi() {
    return 'Meow, ' + super.sayHi(); // 调用父类的 sayHi()
  }
}

let c = new Cat('Tom'); // Tom
console.log(c.sayHi()); // Meow, My name is Tom
</code></pre>
<h5><a id="%E5%AD%98%E5%8F%96%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>存取器</h5>
<p>使用getter和setter可以改变属性的赋值和读取行为；</p>
<pre class="line-numbers"><code class="language-plain_text">class Animal {
  constructor(name) {
    this.name = name;
  }
  get name() {
    return 'Jack';
  }
  set name(value) {
    console.log('setter: ' + value);
  }
}

let a = new Animal('Kitty'); // setter: Kitty
a.name = 'Tom'; // setter: Tom
console.log(a.name); // Jack
</code></pre>
<h5><a id="%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态方法</h5>
<p>使用<code>static</code>修饰符修饰的方法称为静态方法，他们不需要实例化，而是直接通过类来调用：</p>
<pre class="line-numbers"><code class="language-plain_text">class Animal {
  static isAnimal(a) {
    return a instanceof Animal;
  }
}

let a = new Animal('Jack');
Animal.isAnimal(a); // true
a.isAnimal(a); // TypeError: a.isAnimal is not a function
</code></pre>
<h4><a id="typescript%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeScript中类的用法</h4>
<h5><a id="public-private%E5%92%8Cprotected" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>public private和protected</h5>
<p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p>
<ul>
<li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li>
<li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>
<li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">class Animal {
	public name;
	public constructor (name) {
		this.name = name
	}
}
let a = new Animal('Jack')
console.log(a.name) // Jack
a.name = 'Tom'
console.log(a.name) // Tom
</code></pre>
<p>面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。</p>
<p>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了：</p>
<pre class="line-numbers"><code class="language-plain_text">class Animal {
	private name;
	public constructor (name) {
		this.name = name
	}
}
let a = new Animal('Jack')
console.log(a.name) // Jack
a.name = 'Tom' // a是私有的，不允许在外面赋值
// error TS2341: Property 'name' is private and only accessible within class 'Animal'.
</code></pre>
<p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：</p>
<pre class="line-numbers"><code class="language-plain_text">class Animal {
  private name;
  public constructor(name) {
    this.name = name;
  }
}

class Cat extends Animal {
  constructor(name) {
    super(name);
    console.log(this.name);
  }
}

// index.ts(11,17): error TS2341: Property 'name' is private and only accessible within class 'Animal'.
</code></pre>
<p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问：</p>
<pre class="line-numbers"><code class="language-plain_text">class Animal {
  protected name;
  public constructor(name) {
    this.name = name;
  }
}

class Cat extends Animal {
  constructor(name) {
    super(name);
    console.log(this.name);
  }
}
</code></pre>
<p>当构造函数修饰为 <code>private</code> 时，该类不允许被继承或者实例化：</p>
<pre class="line-numbers"><code class="language-plain_text">class Animal {
  public name;
  private constructor(name) {
    this.name = name;
  }
}
class Cat extends Animal {
  constructor(name) {
    super(name);
  }
}

let a = new Animal('Jack');

// index.ts(7,19): TS2675: Cannot extend a class 'Animal'. Class constructor is marked as private.
// index.ts(13,9): TS2673: Constructor of class 'Animal' is private and only accessible within the class declaration.
</code></pre>
<p>当构造函数修饰为 <code>protected</code> 时，该类只允许被继承：</p>
<pre class="line-numbers"><code class="language-plain_text">class Animal {
  public name;
  protected constructor(name) {
    this.name = name;
  }
}
class Cat extends Animal {
  constructor(name) {
    super(name);
  }
}

let a = new Animal('Jack');

// index.ts(13,9): TS2674: Constructor of class 'Animal' is protected and only accessible within the class declaration.
</code></pre>
<h5><a id="%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数属性</h5>
<p>修饰符和<code>readonly</code>还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。</p>
<pre class="line-numbers"><code class="language-plain_text">class Animal {
  // public name: string;
  public constructor(public name) {
    // this.name = name;
  }
}
</code></pre>
<h5><a id="readonly" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>readonly</h5>
<p>只读属性关键字，只允许出现在属性声明或者索引签名或构造函数中。</p>
<pre class="line-numbers"><code class="language-plain_text">class Animal {
  readonly name;
  public constructor(name) {
    this.name = name;
  }
}

let a = new Animal('Jack');
console.log(a.name); // Jack
a.name = 'Tom';

// index.ts(10,3): TS2540: Cannot assign to 'name' because it is a read-only property.
</code></pre>
<p>注意如果 <code>readonly</code> 和其他访问修饰符同时存在的话，需要写在其后面。</p>
<pre class="line-numbers"><code class="language-plain_text">class Animal {
  // public readonly name;
  public constructor(public readonly name) {
    // this.name = name;
  }
}
</code></pre>
<h5><a id="%E6%8A%BD%E8%B1%A1%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>抽象类</h5>
<p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p>
<p>什么是抽象类？</p>
<p>首先，抽象类是不允许被实例化的：</p>
<pre class="line-numbers"><code class="language-plain_text">abstract class Animal {
  public name;
  public constructor(name) {
    this.name = name;
  }
  public abstract sayHi();
}

let a = new Animal('Jack');

// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'.
</code></pre>
<p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</p>
<p>其次，抽象类中的抽象方法必须被子类实现：</p>
<pre class="line-numbers"><code class="language-plain_text">abstract class Animal {
  public name;
  public constructor(name) {
    this.name = name;
  }
  public abstract sayHi();
}

class Cat extends Animal {
  public eat() {
    console.log(`${this.name} is eating.`);
  }
}

let cat = new Cat('Tom');

// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'.
</code></pre>
<p>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译报错了。</p>
<p>下面是一个正确使用抽象类的例子：</p>
<pre class="line-numbers"><code class="language-plain_text">abstract class Animal {
  public name;
  public constructor(name) {
    this.name = name;
  }
  public abstract sayHi();
}

class Cat extends Animal {
  public sayHi() {
    console.log(`Meow, My name is ${this.name}`);
  }
}

let cat = new Cat('Tom');
</code></pre>
<p>上面的例子中，我们实现了抽象方法 <code>sayHi</code>，编译通过了。</p>
<p>需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：</p>
<pre class="line-numbers"><code class="language-plain_text">var __extends =
  (this &amp;&amp; this.__extends) ||
  function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
  };
var Animal = (function () {
  function Animal(name) {
    this.name = name;
  }
  return Animal;
})();
var Cat = (function (_super) {
  __extends(Cat, _super);
  function Cat() {
    _super.apply(this, arguments);
  }
  Cat.prototype.sayHi = function () {
    console.log('Meow, My name is ' + this.name);
  };
  return Cat;
})(Animal);
var cat = new Cat('Tom');
</code></pre>
<h5><a id="%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类的类型</h5>
<p>给类加上 TypeScript 的类型很简单，与接口类似</p>
<pre class="line-numbers"><code class="language-plain_text">class Animal {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
  sayHi(): string {
    return `My name is ${this.name}`;
  }
}

let a: Animal = new Animal('Jack');
console.log(a.sayHi()); // My name is Jack
</code></pre>
<h3><a id="%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类与接口</h3>
<h5><a id="%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类实现接口</h5>
<p>实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p>
<p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Alarm {
	alert(): void
}
class SecurityDoor extends Door implements Alarm {
    alert() {
        console.log('SecurityDoor alert');
    }
}

class Car implements Alarm {
    alert() {
        console.log('Car alert');
    }
}
</code></pre>
<p>一个类可以实现多个接口：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Alarm {
    alert(): void;
}

interface Light {
    lightOn(): void;
    lightOff(): void;
}

class Car implements Alarm, Light {
    alert() {
        console.log('Car alert');
    }
    lightOn() {
        console.log('Car light on');
    }
    lightOff() {
        console.log('Car light off');
    }
}
</code></pre>
<p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code> 接口，既能报警，也能开关车灯。</p>
<h5><a id="%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口继承接口</h5>
<p>接口与接口直接可以是继承关系：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Alarm {
	alert(): void
}
interface LightableAlarm extends Alarm {
    lightOn(): void;
    lightOff(): void;
}
</code></pre>
<p>这很好理解，<code>LightableAlarm</code> 继承了 <code>Alarm</code>，除了拥有 <code>alert</code> 方法之外，还拥有两个新方法 <code>lightOn</code> 和 <code>lightOff</code>。</p>
<h5><a id="%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口继承类</h5>
<p>常见的面向对象语言中，接口时不能继承类的，但是在TypeScript中却是可以的。</p>
<pre class="line-numbers"><code class="language-plain_text">class Point {
    x: number;
    y: number;
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
}

interface Point3d extends Point {
    z: number;
}

let point3d: Point3d = {x: 1, y: 2, z: 3};
</code></pre>
<p>为什么 TypeScript 会支持接口继承类呢？</p>
<p>实际上，当我们在声明 <code>class Point</code> 时，除了会创建一个名为 <code>Point</code> 的类之外，同时也创建了一个名为 <code>Point</code> 的类型（实例的类型）。</p>
<p>所以我们既可以将 <code>Point</code> 当做一个类来用（使用 <code>new Point</code> 创建它的实例）：</p>
<pre class="line-numbers"><code class="language-plain_text">class Point {
    x: number;
    y: number;
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
}

const p = new Point(1, 2);
</code></pre>
<p>也可以将 <code>Point</code> 当做一个类型来用（使用 <code>: Point</code> 表示参数的类型）：</p>
<pre class="line-numbers"><code class="language-plain_text">class Point {
    x: number;
    y: number;
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
}

function printPoint(p: Point) {
    console.log(p.x, p.y);
}

printPoint(new Point(1, 2));
</code></pre>
<p>这个例子实际上可以等价于：</p>
<pre class="line-numbers"><code class="language-plain_text">class Point {
    x: number;
    y: number;
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
}

interface PointInstanceType {
    x: number;
    y: number;
}

function printPoint(p: PointInstanceType) {
    console.log(p.x, p.y);
}

printPoint(new Point(1, 2));
</code></pre>
<p>上例中我们新声明的 <code>PointInstanceType</code> 类型，与声明 <code>class Point</code> 时创建的 <code>Point</code> 类型是等价的。</p>
<p>所以回到 <code>Point3d</code> 的例子中，我们就能很容易的理解为什么 TypeScript 会支持接口继承类了：</p>
<pre class="line-numbers"><code class="language-plain_text">class Point {
    x: number;
    y: number;
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
}

interface PointInstanceType {
    x: number;
    y: number;
}

// 等价于 interface Point3d extends PointInstanceType
interface Point3d extends Point {
    z: number;
}

let point3d: Point3d = {x: 1, y: 2, z: 3};
</code></pre>
<p>当我们声明 <code>interface Point3d extends Point</code> 时，<code>Point3d</code> 继承的实际上是类 <code>Point</code> 的实例的类型。</p>
<p>换句话说，可以理解为定义了一个接口 <code>Point3d</code> 继承另一个接口 <code>PointInstanceType</code>。</p>
<p>所以「接口继承类」和「接口继承接口」没有什么本质的区别。</p>
<p>值得注意的是，<code>PointInstanceType</code> 相比于 <code>Point</code>，缺少了 <code>constructor</code> 方法，这是因为声明 <code>Point</code> 类时创建的 <code>Point</code> 类型是不包含构造函数的。另外，除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法）。</p>
<p>换句话说，声明 <code>Point</code> 类时创建的 <code>Point</code> 类型只包含其中的实例属性和实例方法：</p>
<pre class="line-numbers"><code class="language-plain_text">class Point {
    /** 静态属性，坐标系原点 */
    static origin = new Point(0, 0);
    /** 静态方法，计算与原点距离 */
    static distanceToOrigin(p: Point) {
        return Math.sqrt(p.x * p.x + p.y * p.y);
    }
    /** 实例属性，x 轴的值 */
    x: number;
    /** 实例属性，y 轴的值 */
    y: number;
    /** 构造函数 */
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
    /** 实例方法，打印此点 */
    printPoint() {
        console.log(this.x, this.y);
    }
}

interface PointInstanceType {
    x: number;
    y: number;
    printPoint(): void;
}

let p1: Point;
let p2: PointInstanceType;
</code></pre>
<p>上例中最后的类型 <code>Point</code> 和类型 <code>PointInstanceType</code> 是等价的。</p>
<p>同样的，在接口继承类的时候，也只会继承它的实例属性和实例方法。</p>
<h3><a id="%E6%B3%9B%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>泛型</h3>
<p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
<h4><a id="%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在函数中使用泛型</h4>
<p>先来看一段代码：</p>
<pre class="line-numbers"><code class="language-plain_text">function join(a: number | string, b: number | string) {
  return `${a} ${b}`;
}
</code></pre>
<p>这是一段很水的代码，作为萌新也一下就能看出来，a和b能传数字也能传字符串，最后的返回值，就是利用字符串模板将两者拼起来，其中我们传值有这么4种可能</p>
<ul>
<li>a数字 b数字</li>
<li>a字符串b字符串</li>
<li>a数字b字符串</li>
<li>a字符串b数字</li>
</ul>
<p>但最终的结果依然是拼接，这个时候来了这么个需求，我们必须2个变量的类型要统一，我擦类，这怎么搞，这个时候掏出泛型，改写下代码并这么使用就可以了</p>
<pre class="line-numbers"><code class="language-plain_text">function join&lt;T&gt; (a: T, b: T) {
  return `${a} ${b}`;
}

join&lt;number&gt;(1, 2);
join&lt;string&gt;('1', '2');
// join&lt;number&gt;(1, '2'); //这行报错，你都规定是number了，字符串2是什么鬼
// join&lt;string&gt;(1, '2'); //这行也报错，你都规定是string了，数字1是什么鬼
</code></pre>
<p>在方法执行的括号前加上尖括号，指定类型就可以了(可以省略尖括号，ts会类型推断，但不建议这么做)，这样也约束了参数的类型，这就是最基本最基础的一个使用方式了</p>
<h4><a id="%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数中使用泛型 2</h4>
<p>我们同样也可以约束数组每一项的类型，比如写一个最简单的函数，传入个数组，并返回这个数组</p>
<pre class="line-numbers"><code class="language-plain_text">function getArr&lt;T&gt;(arr: T[]) {
  return arr;
}

getArr&lt;number&gt;([1, 2, 3]) //指定了number，那我的数组必须每一项也是number，如果不是就报错
getArr&lt;string&gt;(['g', 'q', 'f']) //同理这里指定了string
</code></pre>
<h4><a id="%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数中使用泛型3</h4>
<p>获取对象对应key的value，那大家都知道使用<code>obj[key]</code>就可以了，但有的对象我们并不知道有没有这个key，用泛型的话可以很好的解决这个问题</p>
<pre class="line-numbers"><code class="language-plain_text">function getVal&lt;T&gt;(obj: T, k: keyof T){
  return obj[k];
}

interface Person {
  name: string;
  age: number;
}

getVal&lt;Person&gt;({
  name: 'gqf',
  age: 29
}, 'age') // 这里的key值只能传name或者age，否则就会报错，这个就是泛型的力量
</code></pre>
<h4><a id="%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在函数中使用泛型4</h4>
<pre class="line-numbers"><code class="language-plain_text">function manyTest&lt;K, V&gt;(a: K, b: V) {
  return `${a} ${b}`
}

manyTest&lt;number, string&gt;(1, '2') //泛型指定了第一个参数是数字，第二个参数是字符串，所以对应的参数也要这么传
</code></pre>
<h4><a id="%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>泛型接口</h4>
<p>模拟请求相应的场景，初始代码</p>
<pre class="line-numbers"><code class="language-plain_text">interface IResponseData{
    code: number;
    message?: string;
    data: any;
}
async function getData(url: string){
  let response = await fetch(url);
  let data = await response.json();
  return data;
} 
</code></pre>
<p>上述代码很明显有个问题，我们会发现该接口的data项的具体格式不确定，不同的接口会返回的数据是不一样的，当我们想根据具体当前请求的接口返回具体data格式的时候，就比较麻烦了，因为getData并不清楚你调用的具体接口是什么，对应的数据又会是什么，这个时候我们可以对IResponseData使用泛型</p>
<pre class="line-numbers"><code class="language-plain_text">interface IResponseData&lt;T&gt;{
    code: number;
    message?: string;
    data: T;
}

// 用户接口
interface IResponseUserData{
    id: number;
    username: string;
    email: string;
}

// 文章接口
interface IResponseArticleData{
    id: number;
    title: string;
    author: IResponseUserData; 
} 

async function getData&lt;U&gt;(url: string){
    let response = await fetch(url);
    let data: Promise&lt;IResponseData&lt;U&gt;&gt; = await response.json(); // 注意这里返回的是个Promise，然后我们根据不同的接口，指定不同的data数据格式
    return data;
} 

(async function(){
    let userData = await getData&lt;IResponseUserData&gt;('/user');
    userData.data.username;

    let articleData = await getData&lt;IResponseArticleData&gt;('/article');
    articleData.data.author.email;
})()
</code></pre>
<h4><a id="%E5%9C%A8%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在类中使用泛型</h4>
<pre class="line-numbers"><code class="language-plain_text">class AddClass&lt;T&gt; {
    parmas: T;
    add: (x: T, y: T) =&gt; T;
}

let addNumber = new AddClass&lt;number&gt;();
addNumber.parmas = 0;
addNumber.add = function(x, y) { return x + y; };

</code></pre>
<h4><a id="%E5%A4%9A%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多参数类型</h4>
<pre class="line-numbers"><code class="language-plain_text">function returnParamsArr&lt;T, U&gt;(a: T, b:U):[U, T] {
    return  [b, a];
}

class AddClass&lt;T, U&gt; {
    parmas: U;
    add: (x: T, y: U) =&gt; [U, T];
}

interface Add&lt;T, U&gt; {
	parmas: U;
	add: (x: T, y: U) =&gt; [U, T];
}
</code></pre>
<h3><a id="%E6%B5%81%E5%8A%A8%E7%9A%84%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>流动的类型</h3>
<h4><a id="%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>捕获变量的类型</h4>
<p>你可以通过 <code>typeof</code> 操作符在类型注解中使用变量。这允许你告诉编译器，一个变量的类型与其他类型相同，如下所示：</p>
<pre class="line-numbers"><code class="language-plain_text">let foo = 123;
let bar: typeof foo; // 'bar' 类型与 'foo' 类型相同（在这里是： 'number'）

bar = 456; // ok
bar = '789'; // Error: 'string' 不能分配给 'number' 类型
</code></pre>
<h4><a id="%E6%8D%95%E8%8E%B7%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>捕获类成员的类型</h4>
<p>与捕获变量的类型相似，你仅仅是需要声明一个变量用来捕获到的类型：</p>
<pre class="line-numbers"><code class="language-plain_text">class Foo {
  foo: number; // 我们想要捕获的类型
}

declare let _foo: Foo;

// 与之前做法相同
let bar: typeof _foo.foo;
</code></pre>
<h4><a id="%E6%8D%95%E8%8E%B7%E9%94%AE%E7%9A%84%E5%90%8D%E7%A7%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>捕获键的名称</h4>
<p><code>keyof</code> 操作符能让你捕获一个类型的键。例如，你可以使用它来捕获变量的键名称，在通过使用 <code>typeof</code> 来获取类型之后：</p>
<p><code>keyof</code> 与 <code>Object.keys</code> 略有相似，只不过 <code>keyof</code> 取 <code>interface</code> 的键。</p>
<pre class="line-numbers"><code class="language-plain_text">const colors = {
  red: 'red',
  blue: 'blue'
};

type Colors = keyof typeof colors;

let color: Colors; // color 的类型是 'red' | 'blue'
color = 'red'; // ok
color = 'blue'; // ok
color = 'anythingElse'; // Error
</code></pre>
<h3><a id="%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>声明合并</h3>
<p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型：</p>
<h5><a id="%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%88%E5%B9%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数的合并</h5>
<p><a href="https://ts.xcatliu.com/basics/type-of-function.html#%E9%87%8D%E8%BD%BD">之前学习过</a>，我们可以使用重载定义多个函数类型：</p>
<pre class="line-numbers"><code class="language-plain_text">function reverse(x: number): number;
function reverse(x: string): string;
function reverse(x: number | string): number | string {
    if (typeof x === 'number') {
        return Number(x.toString().split('').reverse().join(''));
    } else if (typeof x === 'string') {
        return x.split('').reverse().join('');
    }
}
</code></pre>
<h5><a id="%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%90%88%E5%B9%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口的合并</h5>
<p>接口中的属性在合并时会简单的合并到一个接口中：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Alarrm {
	price: number
}
interface Alarm {
	weight: number
}
</code></pre>
<p>相当于：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Alarm {
    price: number;
    weight: number;
}
</code></pre>
<p>注意，<strong>合并的属性的类型必须是唯一的</strong>：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Alarm {
    price: number;
}
interface Alarm {
    price: number;  // 虽然重复了，但是类型都是 `number`，所以不会报错
    weight: number;
}
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">interface Alarm {
    price: number;
}
interface Alarm {
    price: string;  // 类型不一致，会报错
    weight: number;
}

// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable 'price' must be of type 'number', but here has type 'string'.
</code></pre>
<p>接口中方法的合并，与函数的合并一样：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Alarm {
    price: number;
    alert(s: string): string;
}
interface Alarm {
    weight: number;
    alert(s: string, n: number): string;
}
</code></pre>
<p>相当于：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Alarm {
    price: number;
    weight: number;
    alert(s: string): string;
    alert(s: string, n: number): string;
}
</code></pre>
<h5><a id="%E7%B1%BB%E7%9A%84%E5%90%88%E5%B9%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类的合并</h5>
<p>类的合并与接口的合并规则一致。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScript --- 基础篇]]></title>
    <link href="https://www.bwrong.cn/17280550301522.html"/>
    <updated>2024-10-04T23:17:10+08:00</updated>
    <id>https://www.bwrong.cn/17280550301522.html</id>
    <content type="html"><![CDATA[
<h3><a id="%E4%BB%80%E4%B9%88%E6%98%AFtypescript" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是TypeScript</h3>
<p><a href="http://www.typescriptlang.org/">TypeScript</a> 是 JavaScript 的一个超集，主要提供了<strong>类型系统</strong>和<strong>对 ES6 的支持</strong></p>
<h3><a id="%E5%AE%89%E8%A3%85typescript" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装TypeScript</h3>
<p>TypeScript 的命令行工具安装方法如下：</p>
<pre class="line-numbers"><code class="language-plain_text">npm install -g typescript
</code></pre>
<p>以上命令会在全局环境下安装 <code>tsc</code> 命令，安装完成之后，我们就可以在任何地方执行 <code>tsc</code> 命令了。</p>
<p>编译一个 TypeScript 文件很简单：</p>
<pre class="line-numbers"><code class="language-plain_text">tsc hello.ts
</code></pre>
<p>我们约定使用 TypeScript 编写的文件以 <code>.ts</code> 为后缀，用 TypeScript 编写 React 时，以 <code>.tsx</code> 为后缀。</p>
<h3><a id="typescript%E5%92%8Cjavascript%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeScript和JavaScript的区别</h3>
<table>
<thead>
<tr>
<th style="text-align: center">TypeScript</th>
<th style="text-align: center">JavaScript</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">JavaScript 的超集用于解决大型项目的代码复杂性</td>
<td style="text-align: center">一种脚本语言，用于创建动态网页</td>
</tr>
<tr>
<td style="text-align: center">可以在编译期间发现并纠正错误</td>
<td style="text-align: center">作为一种解释型语言，只能在运行时发现错误</td>
</tr>
<tr>
<td style="text-align: center">支持静态和动态类型</td>
<td style="text-align: center">没有静态类型选项</td>
</tr>
<tr>
<td style="text-align: center">最终被编译成 JavaScript 代码，使浏览器可以理解</td>
<td style="text-align: center">可以直接在浏览器中使用</td>
</tr>
<tr>
<td style="text-align: center">支持模块、泛型和接口</td>
<td style="text-align: center">不支持模块，泛型或接口</td>
</tr>
<tr>
<td style="text-align: center">社区的支持仍在增长，而且还不是很大</td>
<td style="text-align: center">大量的社区支持以及大量文档和解决问题的支持</td>
</tr>
</tbody>
</table>
<h5><a id="" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a></h5>
<h3><a id="%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础数据类型</h3>
<p>原始数据类型包括：布尔值、数值、字符串、<code>null</code>、<code>undefined</code> 以及 <a href="http://es6.ruanyifeng.com/#docs/symbol">ES6 中的新类型 <code>Symbol</code></a>。</p>
<h4><a id="%E5%B8%83%E5%B0%94%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>布尔值</h4>
<p>布尔值是最基础的数据类型，在 TypeScript 中，使用 <code>boolean</code> 定义布尔值类型：</p>
<pre class="line-numbers"><code class="language-plain_text">let isDone: boolean = false
</code></pre>
<p>注意，使用构造函数 <code>Boolean</code> 创造的对象<strong>不是</strong>布尔值,返回的是一个Boolean对象</p>
<pre class="line-numbers"><code class="language-plain_text">let createdByNewBoolean: boolean = new Boolean(1);
// Type 'Boolean' is not assignable to type 'boolean'.
// 'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.
</code></pre>
<h4><a id="%E6%95%B0%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数值</h4>
<p>使用number定义数值类型：</p>
<pre class="line-numbers"><code class="language-plain_text">let count: number = 6
/ ES6 中的二进制表示法
let binaryLiteral: number = 0b1010;
// ES6 中的八进制表示法
let octalLiteral: number = 0o744;
</code></pre>
<h4><a id="%E5%AD%97%E7%AC%A6%E4%B8%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符串</h4>
<p>使用string定义字符串类型：</p>
<pre class="line-numbers"><code class="language-plain_text">let myName: string = 'Tom';
let myAge: number = 25;

// 模板字符串
let sentence: string = `Hello, my name is ${myName}.
I'll be ${myAge + 1} years old next month.`;
</code></pre>
<h4><a id="%E7%A9%BA%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>空值</h4>
<p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 <code>void</code> 表示没有任何返回值的函数：</p>
<pre class="line-numbers"><code class="language-plain_text">function alertName: void {
	alert('My name is Tom')
}
</code></pre>
<p>声明一个 <code>void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code>undefined</code> 和 <code>null</code>：</p>
<pre class="line-numbers"><code class="language-plain_text">let unusable: void = undefined;
</code></pre>
<h4><a id="null%E5%92%8C-undefined" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Null 和 Undefined</h4>
<p>在 TypeScript 中，可以使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型：</p>
<pre class="line-numbers"><code class="language-plain_text">let u: undefined = undefined;
let n: null = null;
</code></pre>
<p>与 <code>void</code> 的区别是，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量：</p>
<pre class="line-numbers"><code class="language-plain_text">// 这样不会报错
let num: number = undefined;
</code></pre>
<h4><a id="never" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>never</h4>
<p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如，<code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p>
<pre class="line-numbers"><code class="language-plain_text">// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}
</code></pre>
<h4><a id="%E4%BB%BB%E6%84%8F%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>任意值</h4>
<p>任意值(Any)用来表示允许赋值任意类型</p>
<h5><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是任意类型</h5>
<p>如果是一个普通类型，在赋值过程中改变类型是不被允许的：</p>
<pre class="line-numbers"><code class="language-plain_text">let myFavoriteNumber: string = 'seven';
myFavoriteNumber = 7;
// error Type 'number' is not assignable to type 'string'.
</code></pre>
<p>但如果是any类型，则允许被赋值位任意类型</p>
<pre class="line-numbers"><code class="language-plain_text">let myFavoriteNumber: any = 'seven';
myFavoriteNumber = 7
// it’s ok
</code></pre>
<h5><a id="%E4%BB%BB%E6%84%8F%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>任意值的属性和方法</h5>
<p>在任意值上访问的任何属性都是被允许的：</p>
<pre class="line-numbers"><code class="language-plain_text">let anyThing: any = 'hello';
console.log(anyThing.myName);
console.log(anyThing.myName.firstName);
</code></pre>
<p>也允许调用任何方法：</p>
<pre class="line-numbers"><code class="language-plain_text">let anyThing: any = 'Tom';
anyThing.setName('Jerry');
anyThing.setName('Jerry').sayHello();
anyThing.myName.setFirstName('Cat');
</code></pre>
<p>可以认为，<strong>声明以一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</strong></p>
<h5><a id="%E6%9C%AA%E5%A3%B0%E5%91%BD%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>未声命类型的变量</h5>
<p><strong>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</strong>：</p>
<pre class="line-numbers"><code class="language-plain_text">let something;
something = 'seven';
something = 7;

something.setName('Tom');
</code></pre>
<p>等价于：</p>
<pre class="line-numbers"><code class="language-plain_text">let something: any;
something = 'seven';
something = 7;

something.setName('Tom');
</code></pre>
<h4><a id="unkonw" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>unkonw</h4>
<p>TypeScript 3.0 引入了新的<code>unknown</code> 类型，它是 <code>any</code> 类型对应的安全类型。</p>
<p>当我们在写应用的时候可能会需要描述一个我们还不知道其类型的变量。这些值可以来自动态内容，例如从用户获得，或者我们想在我们的 API 中接收所有可能类型的值。在这些情况下，我们想要让编译器以及未来的用户知道这个变量可以是任意类型。这个时候我们会对它使用 <code>unknown</code> 类型。</p>
<p>就像所有类型都可以赋值给 <code>any</code>，所有类型也都可以赋值给 <code>unknown</code>。这使得 <code>unknown</code> 成为 TypeScript 类型系统的另一种顶级类型（另一种是 <code>any</code>）。</p>
<pre class="line-numbers"><code class="language-plain_text">let value: unknown;

value = true; // OK
value = 42; // OK
value = &quot;Hello World&quot;; // OK
value = []; // OK
value = {}; // OK
value = Math.random; // OK
value = null; // OK
value = undefined; // OK
value = new TypeError(); // OK
value = Symbol(&quot;type&quot;); // OK
</code></pre>
<p>对 <code>value</code> 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 <code>unknown</code> 的值赋值给其他类型的变量时会发生什么？</p>
<pre class="line-numbers"><code class="language-plain_text">let value: unknown;

let value1: unknown = value; // OK
let value2: any = value; // OK
let value3: boolean = value; // Error
let value4: number = value; // Error
let value5: string = value; // Error
let value6: object = value; // Error
let value7: any[] = value; // Error
let value8: Function = value; // Error
</code></pre>
<p><code>unknown</code> 类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 <code>unknown</code> 类型的值。毕竟我们不知道变量 <code>value</code> 中存储了什么类型的值。</p>
<h3><a id="%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型推断</h3>
<p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p>
<h4><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是类型推断</h4>
<p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p>
<pre class="line-numbers"><code class="language-plain_text">let myFavoriteNumber = 'seven';
myFavoriteNumber = 7;
// error TS2322: Type 'number' is not assignable to type 'string'.
</code></pre>
<p>等价于：</p>
<pre class="line-numbers"><code class="language-plain_text">let myFavoriteNumber: string = 'seven';
myFavoriteNumber = 7;
// error TS2322: Type 'number' is not assignable to type 'string'.
</code></pre>
<p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p>
<h5><a id="%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义变量</h5>
<pre class="line-numbers"><code class="language-plain_text">let a = 1
let b = '2'
</code></pre>
<h5><a id="%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数返回类型</h5>
<pre class="line-numbers"><code class="language-plain_text">function add(x: number, y: string) {
	return a + b
}
</code></pre>
<h5><a id="%E8%B5%8B%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>赋值</h5>
<pre class="line-numbers"><code class="language-plain_text">type Adder = (a: number, b: number) =&gt; number;
let foo: Adder = (a, b) =&gt; a + b;
</code></pre>
<h5><a id="%E7%BB%93%E6%9E%84%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结构化</h5>
<pre class="line-numbers"><code class="language-plain_text">const foo = {
	a: 123,
	b: 234
}
foo.a = '123' // Error：不能把 'string' 类型赋值给 'number' 类型
</code></pre>
<h5><a id="%E8%A7%A3%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解构</h5>
<pre class="line-numbers"><code class="language-plain_text">const foo = {
  a: 123,
  b: 456
};
let { a } = foo;

a = 'hello'; // Error：不能把 'string' 类型赋值给 'number' 类型
</code></pre>
<p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查</strong>：</p>
<pre class="line-numbers"><code class="language-plain_text">let myFavoriteNumber;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;
</code></pre>
<h3><a id="%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>联合类型</h3>
<p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p>
<h4><a id="%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简单的例子</h4>
<pre class="line-numbers"><code class="language-plain_text">let count : string | number
count = 7
count = '7'
// it's ok
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">let count : string | number
count = 7
count = true
// error Type 'boolean' is not assignable to type 'string | number'.
</code></pre>
<p><strong>联合类型使用 <code>|</code> 分隔每个类型。</strong></p>
<h4><a id="%E8%AE%BF%E9%97%AE%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E6%88%96%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>访问联合类型的属性或方法</h4>
<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p>
<pre class="line-numbers"><code class="language-plain_text">function getLength(something: string | number): number {
    return something.length;
}

// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.
//   Property 'length' does not exist on type 'number'.
</code></pre>
<p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p>
<p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p>
<pre class="line-numbers"><code class="language-plain_text">function getString(something: string | number): string {
    return something.toString();
}
</code></pre>
<p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p>
<pre class="line-numbers"><code class="language-plain_text">let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
console.log(myFavoriteNumber.length); // 5
myFavoriteNumber = 7;
console.log(myFavoriteNumber.length); // 编译时报错

// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'.
</code></pre>
<p>例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</p>
<p>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了。</p>
<h3><a id="%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对象的类型 -- 接口</h3>
<p><strong>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</strong></p>
<h4><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是接口</h4>
<p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p>
<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于<a href="https://ts.xcatliu.com/advanced/class-and-interfaces.html#%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述。</p>
<h4><a id="%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简单的例子</h4>
<pre class="line-numbers"><code class="language-plain_text">interface Person {
    name: string;
    age: number;
}

let tom: Person = {
    name: 'Tom',
    age: 25
};
</code></pre>
<p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。</p>
<p>定义的变量比接口少了一些属性是不允许的：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Person {
    name: string;
    age: number;
}

let tom: Person = {
    name: 'Tom'
};

//  error TS2322: Type '{ name: string; }' is not assignable to type 'Person'.
//  Property 'age' is missing in type '{ name: string; }'.
</code></pre>
<p>多一些属性也是不允许的：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Person {
    name: string;
    age: number;
}

let tom: Person = {
    name: 'Tom',
    age: 25,
    gender: 'male'
};

// error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.
// Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.
</code></pre>
<p>可见，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p>
<h4><a id="%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可选属性</h4>
<p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Person {
    name: string;
    age?: number;
}

let tom: Person = {
    name: 'Tom'
};
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">interface Person {
    name: string;
    age?: number;
}

let tom: Person = {
    name: 'Tom',
    age: 25
};
</code></pre>
<p>可选属性的含义是该属性可以不存在。</p>
<p>这时<strong>仍然不允许添加未定义的属性</strong>：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Person {
    name: string;
    age?: number;
}

let tom: Person = {
    name: 'Tom',
    age: 25,
    gender: 'male'
};
</code></pre>
<h4><a id="%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>任意属性</h4>
<p>有时候我们希望一个接口有任意属性，可以使用如下方式：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Person {
	name: string;
	age?: number;
	[propName: string]: any;
}
let tom: Person = {
	name: 'Tom',
	age: 20,
	gender: 'male'
}
</code></pre>
<p>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</strong>：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Person {
	name: string;
	age?: number;
	[propName: string]: string
}
let tom: Person = {
	name: 'tom',
	age: 24,
	gender: 'male'
}
// error Property 'age' of type 'number' is not assignable to string index type 'string'.
</code></pre>
<p>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p>
<p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Person {
	name: string;
	age?: number;
	[propName: string]: number | string
}
let tom: Person = {
	name: 'tom',
	age: 24,
	gender: 'male'
}
</code></pre>
<h4><a id="%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>只读属性</h4>
<p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Person {
	readonly id: number;
	name: string;
	age?: number;
	[propName: string]: number | string
}
let tom: Person = {
	id: 1,
	name: 'tom'
}
tom.id = 2 // error Cannot assign to 'id' because it is a constant or a read-only property.
</code></pre>
<p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong>：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Person = {
	readonly id: number;
	name: string;
	age?: number;
	[propName: string]: string | number
}
let tom: Person = {
	name: 'tom',
	age: 23
}
tom.id = 1
// error Type '{ name: string; gender: string; }' is not assignable to type 'Person'.
Property 'id' is missing in type '{ name: string; gender: string; }'.
Cannot assign to 'id' because it is a constant or a read-only property.
</code></pre>
<p>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</p>
<p>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了。</p>
<h3><a id="%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数组的类型</h3>
<p>在TypeScript中，数组的类型有多种定义方式，比较灵活</p>
<h4><a id="%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%8B%AC%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型+方括号 表示法</h4>
<p>最简单的方法是使用【类型+方括号】来表示数组：</p>
<pre class="line-numbers"><code class="language-plain_text">let countArray : number[] = [1,2,3,4,5]
</code></pre>
<p>数组的项中不允许出现其他的类型：</p>
<pre class="line-numbers"><code class="language-plain_text">let countArray: number[] = [1,2,3,'4']
// error Type 'string' is not assignable to type 'number'.
</code></pre>
<p>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：</p>
<pre class="line-numbers"><code class="language-plain_text">let countArray: number[] = [1,2,3,4]
countArray.push('2')
// error Argument of type '&quot;2&quot;' is not assignable to parameter of type 'number'.
</code></pre>
<h4><a id="%E6%95%B0%E7%BB%84%E6%B3%9B%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数组泛型</h4>
<p>我们也可以使用数组泛型（Array Generic） <code>Array&lt;elemType&gt;</code> 来表示数组：</p>
<pre class="line-numbers"><code class="language-plain_text">let countArray: Array&lt;number&gt; = [1,2,3,4,5]
</code></pre>
<p>注：关于泛型，后续会介绍</p>
<h4><a id="%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%A1%A8%E7%A4%BA%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用接口表示数组</h4>
<p>接口也可以用来描述数组：</p>
<pre class="line-numbers"><code class="language-plain_text">interface NumberArray {
	[index: number]: number
}
let countArray: NumberArray = [1,2,3,4,5]
</code></pre>
<p><code>NumberArray</code> 表示：只要索引的类型是数字时，那么值的类型必须是数字。</p>
<p>虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。</p>
<p>不过有一种情况例外，那就是它常用来表示类数组。</p>
<h4><a id="%E7%B1%BB%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类数组</h4>
<p>类数组（Array-like Object）不是数组类型</p>
<pre class="line-numbers"><code class="language-plain_text">function sum() {
    let args: number[] = arguments;
}

// Type 'IArguments' is missing the following properties from type 'number[]': pop, push, concat, join, and 24 more.
</code></pre>
<p>上例中，<code>arguments</code> 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：</p>
<pre class="line-numbers"><code class="language-plain_text">function sum() {
    let args: {
        [index: number]: number;
        length: number;
        callee: Function;
    } = arguments;
}
</code></pre>
<p>在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 <code>length</code> 和 <code>callee</code> 两个属性。</p>
<p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p>
<pre class="line-numbers"><code class="language-plain_text">function sum() {
    let args: IArguments = arguments;
}
</code></pre>
<p>其中 <code>IArguments</code> 是 TypeScript 中定义好了的类型，它实际上就是：</p>
<pre class="line-numbers"><code class="language-plain_text">interface IArguments {
    [index: number]: any;
    length: number;
    callee: Function;
}
</code></pre>
<p>关于内置对象，可以参考<a href="https://ts.xcatliu.com/basics/built-in-objects.html">内置对象</a>一章。</p>
<h4><a id="any%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>any 在数组中的应用</h4>
<p>一个比较常见的作法是，用<code>any</code>表示数组允许出现任何类型</p>
<pre class="line-numbers"><code class="language-plain_text">let countArray:any[] = ['1',2,{name:'12', age: 24}]
</code></pre>
<h3><a id="%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数的类型</h3>
<h4><a id="%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数声明</h4>
<p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：</p>
<pre class="line-numbers"><code class="language-plain_text">// 函数声命式(Function Declaration)
function sum(x,y) {
	return x + y
}
// 函数表达式
let sum = function(x,y) {
	return x + y
}
</code></pre>
<p>一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：</p>
<pre class="line-numbers"><code class="language-plain_text">function sum(x:number,y:number): number {
	return x + y
}
</code></pre>
<p>注意，<strong>输入多余的（或者少于要求的）参数，是不被允许的</strong></p>
<h4><a id="%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数表达式</h4>
<p>如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：</p>
<pre class="line-numbers"><code class="language-plain_text">let mySum = function (x: number, y: number): number {
    return x + y;
};
</code></pre>
<p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样：</p>
<pre class="line-numbers"><code class="language-plain_text">let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {
    return x + y;
};
</code></pre>
<p>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。</p>
<p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>
<h4><a id="%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E7%8A%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用接口定义函数的形状</h4>
<p>我们也可以使用接口的方式来定义一个函数需要符合的形状：</p>
<pre class="line-numbers"><code class="language-plain_text">interface SearchFun {
	(source: string, subString: string): boolean
}
let mySearch: SearchFun
mySearch = function(source: string, subString: string) {
	return source.search(subString) !== -1
}
</code></pre>
<p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p>
<h4><a id="%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可选参数</h4>
<p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p>
<p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p>
<pre class="line-numbers"><code class="language-plain_text">function buildName(firstName: string, lastName?: string) {
	 if (lastName) {
        return firstName + ' ' + lastName;
    } else {
        return firstName;
    }
}
let tomcat = buildName('Tom', 'Cat');
let tom = buildName('Tom');
</code></pre>
<p>需要注意的是，可选参数必须接在必需参数后面。换句话说，<strong>可选参数后面不允许再出现必需参数了</strong>：</p>
<pre class="line-numbers"><code class="language-plain_text">function buildName(firstName?: string, lastName: string) {
    if (firstName) {
        return firstName + ' ' + lastName;
    } else {
        return lastName;
    }
}
let tomcat = buildName('Tom', 'Cat');
let tom = buildName(undefined, 'Tom');

//error TS1016: A required parameter cannot follow an optional parameter.
</code></pre>
<h4><a id="%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数默认值</h4>
<p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p>
<pre class="line-numbers"><code class="language-plain_text">function buildName(firstName: string, lastName: string = 'Cat') {
    return firstName + ' ' + lastName;
}
let tomcat = buildName('Tom', 'Cat');
let tom = buildName('Tom');
</code></pre>
<p>此时就不受「可选参数必须接在必需参数后面」的限制了：</p>
<pre class="line-numbers"><code class="language-plain_text">function buildName(firstName: string = 'Tom', lastName: string) {
    return firstName + ' ' + lastName;
}
let tomcat = buildName('Tom', 'Cat');
let cat = buildName(undefined, 'Cat');
</code></pre>
<h4><a id="%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>剩余参数</h4>
<p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）：</p>
<pre class="line-numbers"><code class="language-plain_text">function push(array, ...items) {
    items.forEach(function(item) {
        array.push(item);
    });
}

let a: any[] = [];
push(a, 1, 2, 3);
</code></pre>
<p>事实上，<code>items</code> 是一个数组。所以我们可以用数组的类型来定义它：</p>
<pre class="line-numbers"><code class="language-plain_text">function push(array: any[], ...items: any[]) {
    items.forEach(function(item) {
        array.push(item);
    });
}

let a = [];
push(a, 1, 2, 3);
</code></pre>
<p>注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#rest%E5%8F%82%E6%95%B0">ES6 中的 rest 参数</a>。</p>
<h4><a id="%E9%87%8D%E8%BD%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重载</h4>
<p>载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p>
<p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>'hello'</code> 的时候，输出反转的字符串 <code>'olleh'</code>。</p>
<p>利用联合类型，我们可以这么实现：</p>
<pre class="line-numbers"><code class="language-plain_text">function reverse(x: number | string): number | string {
    if (typeof x === 'number') {
        return Number(x.toString().split('').reverse().join(''));
    } else if (typeof x === 'string') {
        return x.split('').reverse().join('');
    }
}
</code></pre>
<p><strong>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</strong></p>
<p>这时，我们可以使用重载定义多个 <code>reverse</code> 的函数类型：</p>
<pre class="line-numbers"><code class="language-plain_text">function reverse(x: number): number;
function reverse(x: string): string;
function reverse(x: number | string): number | string {
    if (typeof x === 'number') {
        return Number(x.toString().split('').reverse().join(''));
    } else if (typeof x === 'string') {
        return x.split('').reverse().join('');
    }
}
</code></pre>
<p>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p>
<p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p>
<h3><a id="%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型断言</h3>
<p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p>
<h4><a id="%E8%AF%AD%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>语法</h4>
<pre class="line-numbers"><code class="language-plain_text">值 as 类型
</code></pre>
<p>或</p>
<pre class="line-numbers"><code class="language-plain_text">&lt;类型&gt;值
</code></pre>
<p>在 tsx 语法（React 的 jsx 语法的 ts 版）中必须使用前者，即 <code>值 as 类型</code>。</p>
<p>形如 <code>&lt;Foo&gt;</code> 的语法在 tsx 中表示的是一个 <code>ReactNode</code>，在 ts 中除了表示类型断言之外，也可能是表示一个<a href="https://ts.xcatliu.com/advanced/generics.html">泛型</a>。</p>
<p>故建议大家在使用类型断言时，统一使用 <code>值 as 类型</code> 这样的语法。</p>
<h4><a id="%E5%B0%86%E4%B8%80%E4%B8%AA%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%B8%BA%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>将一个联合类型断言为其中一个类型</h4>
<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型中共有的属性或方法</strong>：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Cat {
    name: string;
    run(): void;
}
interface Fish {
    name: string;
    swim(): void;
}

function getName(animal: Cat | Fish) {
    return animal.name;
}
</code></pre>
<p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Cat {
    name: string;
    run(): void;
}
interface Fish {
    name: string;
    swim(): void;
}

function isFish(animal: Cat | Fish) {
    if (typeof animal.swim === 'function') {
        return true;
    }
    return false;
}

// error TS2339: Property 'swim' does not exist on type 'Cat | Fish'.
// Property 'swim' does not exist on type 'Cat'.
</code></pre>
<p>上面的例子中，获取 <code>animal.swim</code> 的时候会报错。</p>
<p>此时可以使用类型断言，将 <code>animal</code> 断言成 <code>Fish</code>：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Cat {
    name: string;
    run(): void;
}
interface Fish {
    name: string;
    swim(): void;
}

function isFish(animal: Cat | Fish) {
    if (typeof (animal as Fish).swim === 'function') {
        return true;
    }
    return false;
}
</code></pre>
<p>需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Cat {
    name: string;
    run(): void;
}
interface Fish {
    name: string;
    swim(): void;
}

function swim(animal: Cat | Fish) {
    (animal as Fish).swim();
}

const tom: Cat = {
    name: 'Tom',
    run() { console.log('run') }
};
swim(tom);
// Uncaught TypeError: animal.swim is not a function`
</code></pre>
<p>上面的例子编译时不会报错，但在运行时会报错：</p>
<p>原因是 <code>(animal as Fish).swim()</code> 这段代码隐藏了 <code>animal</code> 可能为 <code>Cat</code> 的情况，将 <code>animal</code> 直接断言为 <code>Fish</code> 了，而 TypeScript 编译器信任了我们的断言，故在调用 <code>swim()</code> 时没有编译错误。</p>
<p>可是 <code>swim</code> 函数接受的参数是 <code>Cat | Fish</code>，一旦传入的参数是 <code>Cat</code> 类型的变量，由于 <code>Cat</code> 上没有 <code>swim</code> 方法，就会导致运行时错误了。</p>
<p>总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。</p>
<h4><a id="%E5%B0%86%E4%B8%80%E4%B8%AA%E7%88%B6%E7%B1%BB%E6%96%AD%E8%A8%80%E4%B8%BA%E6%9B%B4%E5%8A%A0%E5%85%B7%E4%BD%93%E7%9A%84%E5%AD%90%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>将一个父类断言为更加具体的子类</h4>
<p>当类之间有继承关系时，类型断言也是很常见的：</p>
<pre class="line-numbers"><code class="language-plain_text">class ApiError extends Error {
    code: number = 0;
}
class HttpError extends Error {
    statusCode: number = 200;
}

function isApiError(error: Error) {
    if (typeof (error as ApiError).code === 'number') {
        return true;
    }
    return false;
}
</code></pre>
<p>上面的例子中，我们声明了函数 <code>isApiError</code>，它用来判断传入的参数是不是 <code>ApiError</code> 类型，为了实现这样一个函数，它的参数的类型肯定得是比较抽象的父类 <code>Error</code>，这样的话这个函数就能接受 <code>Error</code> 或它的子类作为参数了。</p>
<p>但是由于父类 <code>Error</code> 中没有 <code>code</code> 属性，故直接获取 <code>error.code</code> 会报错，需要使用类型断言获取 <code>(error as ApiError).code</code>。</p>
<p>大家可能会注意到，在这个例子中有一个更合适的方式来判断是不是 <code>ApiError</code>，那就是使用 <code>instanceof</code>：</p>
<pre class="line-numbers"><code class="language-plain_text">class ApiError extends Error {
    code: number = 0;
}
class HttpError extends Error {
    statusCode: number = 200;
}

function isApiError(error: Error) {
    if (error instanceof ApiError) {
        return true;
    }
    return false;
}
</code></pre>
<p>上面的例子中，确实使用 <code>instanceof</code> 更加合适，因为 <code>ApiError</code> 是一个 JavaScript 的类，能够通过 <code>instanceof</code> 来判断 <code>error</code> 是否是它的实例。</p>
<p>但是有的情况下 <code>ApiError</code> 和 <code>HttpError</code> 不是一个真正的类，而只是一个 TypeScript 的接口（<code>interface</code>），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 <code>instanceof</code> 来做运行时判断了：</p>
<pre class="line-numbers"><code class="language-plain_text">interface ApiError extends Error {
    code: number;
}
interface HttpError extends Error {
    statusCode: number;
}

function isApiError(error: Error) {
    if (error instanceof ApiError) {
        return true;
    }
    return false;
}

//error TS2693: 'ApiError' only refers to a type, but is being used as a value here.
</code></pre>
<p>此时就只能用类型断言，通过判断是否存在 <code>code</code> 属性，来判断传入的参数是不是 <code>ApiError</code>了：</p>
<pre class="line-numbers"><code class="language-plain_text">interface ApiError extends Error {
    code: number;
}
interface HttpError extends Error {
    statusCode: number;
}

function isApiError(error: Error) {
    if (typeof (error as ApiError).code === 'number') {
        return true;
    }
    return false;
}
</code></pre>
<h4><a id="%E5%B0%86%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%B8%BAany" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>将任何一个类型断言为 <code>any</code></h4>
<p>理想情况下，TypeScript 的类型系统运转良好，每个值的类型都具体而精确。</p>
<p>当我们引用一个在此类型上不存在的属性或方法时，就会报错：</p>
<pre class="line-numbers"><code class="language-plain_text">const foo:number = 1
foo.length = 1
//error TS2339: Property 'length' does not exist on type 'number'.
</code></pre>
<p>上面的例子中，数字类型的变量 <code>foo</code> 上是没有 <code>length</code> 属性的，故 TypeScript 给出了相应的错误提示。</p>
<p>这种错误提示显然是非常有用的。</p>
<p>但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：</p>
<pre class="line-numbers"><code class="language-plain_text">window.foo = 1
// error TS2339: Property 'foo' does not exist on type 'Window &amp; typeof globalThis'.
</code></pre>
<p>面的例子中，我们需要将 <code>window</code> 上添加一个属性 <code>foo</code>，但 TypeScript 编译时会报错，提示我们 <code>window</code> 上不存在 <code>foo</code> 属性。</p>
<p>此时我们可以使用 <code>as any</code> 临时将 <code>window</code> 断言为 <code>any</code> 类型：</p>
<pre class="line-numbers"><code class="language-plain_text">(window as any).foo =  1
</code></pre>
<p>在 <code>any</code> 类型的变量上，访问任何属性都是允许的。</p>
<p>需要注意的是，将一个变量断言为 <code>any</code> 可以说是解决 TypeScript 中类型问题的最后一个手段。</p>
<p><strong>它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 <code>as any</code>。</strong></p>
<p>总之，<strong>一方面不能滥用 <code>as any</code>，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡</strong>（这也是 <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals">TypeScript 的设计理念</a>之一），才能发挥出 TypeScript 最大的价值</p>
<h4><a id="%E5%B0%86any%E6%96%AD%E8%A8%80%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E7%9A%84%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>将<code>any</code>断言为一个具体的类型</h4>
<p>在日常的开发中，我们不可避免的需要处理 <code>any</code> 类型的变量，它们可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。</p>
<p>遇到 <code>any</code> 类型的变量时，我们可以选择无视它，任由它滋生更多的 <code>any</code>。</p>
<p>我们也可以选择改进它，通过类型断言及时的把 <code>any</code> 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。</p>
<p>举例来说，历史遗留的代码中有个 <code>getCacheData</code>，它的返回值是 <code>any</code>：</p>
<pre class="line-numbers"><code class="language-plain_text">function getCacheData(key: string): any {
    return (window as any).cache[key];
}
</code></pre>
<p>那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作：</p>
<pre class="line-numbers"><code class="language-plain_text">function getCacheData(key: string): any {
    return (window as any).cache[key];
}

interface Cat {
    name: string;
    run(): void;
}

const tom = getCacheData('tom') as Cat;
tom.run();
</code></pre>
<p>上面的例子中，我们调用完 <code>getCacheData</code> 之后，立即将它断言为 <code>Cat</code> 类型。这样的话明确了 <code>tom</code> 的类型，后续对 <code>tom</code> 的访问时就有了代码补全，提高了代码的可维护性。</p>
<h4><a id="%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>非空断言</h4>
<p>在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 <code>!</code> 可以用于断言操作对象是非 null 和非 undefined 类型。<strong>具体而言，x! 将从 x 值域中排除 null 和 undefined 。</strong></p>
<h5><a id="%E5%BF%BD%E7%95%A5undefined%E5%92%8Cnull" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>忽略undefined和null</h5>
<pre class="line-numbers"><code class="language-plain_text">function myFunc(maybeString: string | undefined | null) {
  const onlyString: string = maybeString; // Error
  const ignoreUndefinedAndNull: string = maybeString!; // Ok
}
</code></pre>
<h5><a id="%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%97%B6%E5%BF%BD%E7%95%A5undefined" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用函数时忽略undefined</h5>
<pre class="line-numbers"><code class="language-plain_text">type NumGenerator = () =&gt; number;

function myFunc(numGenerator: NumGenerator | undefined) {
  // Object is possibly 'undefined'.(2532)
  // Cannot invoke an object which is possibly 'undefined'.(2722)
  const num1 = numGenerator(); // Error
  const num2 = numGenerator!(); //OK
}
</code></pre>
<h5><a id="%E7%A1%AE%E5%AE%9A%E8%B5%8B%E5%80%BC%E6%96%AD%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>确定赋值断言</h5>
<p>在 TypeScript 2.7 版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 <code>!</code> 号，从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：</p>
<pre class="line-numbers"><code class="language-plain_text">let x: number;
initialize();
// Variable 'x' is used before being assigned.(2454)
console.log(2 * x); // Error

function initialize() {
  x = 10;
}
</code></pre>
<p>很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：</p>
<pre class="line-numbers"><code class="language-plain_text">let x!: number;
initialize();
console.log(2 * x); // Ok

function initialize() {
  x = 10;
}
</code></pre>
<h4><a id="%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E9%99%90%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型断言的限制</h4>
<p>从上面的例子中，我们可以总结出：</p>
<ul>
<li>联合类型可以被断言为其中一个类型</li>
<li>父类可以被断言为子类</li>
<li>任何类型都可以被断言为 any</li>
<li>any 可以被断言为任何类型</li>
</ul>
<h3><a id="%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>声明文件</h3>
<p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p>
<h4><a id="%E6%96%B0%E8%AF%AD%E6%B3%95%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>新语法索引</h4>
<p>由于本章涉及大量新语法，故在本章开头列出新语法的索引，方便大家在使用这些新语法时能快速查找到对应的讲解：</p>
<ul>
<li>declare var 声明全局变量</li>
<li>declare function 声明全局方法</li>
<li>declare class 声明全局类</li>
<li>declare enum 声明全局枚举类型</li>
<li>declare namespace 声明（含有子属性）全局对象</li>
<li>interface 和 type 声明全局类型</li>
<li>export 导出变量</li>
<li>export namespace 导出（含有子类元素）对象</li>
<li>export default ES6默认导出</li>
<li>export as namespace UMD库声明全局变量</li>
<li>export =  commonjs导出模块</li>
<li>declare global 扩展全局变量</li>
<li>declare module 扩展模块</li>
<li>/// <reference/> 三斜线指令</li>
</ul>
<h4><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E8%AF%AD%E5%8F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是声明语句</h4>
<p>假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 <code>&lt;script&gt;</code> 标签引入 jQuery，然后就可以使用全局变量 <code>$</code> 或 <code>jQuery</code> 了。</p>
<p>我们通常这样获取一个id是foo的元素：</p>
<pre class="line-numbers"><code class="language-plain_text">$('#foo')
// or
jQuery('#foo')
</code></pre>
<p>但是在ts种，编译器并不知道<code>$</code>或者<code>jQuery</code>是什么东西：</p>
<pre class="line-numbers"><code class="language-plain_text">jQuery('#foo');
// ERROR: Cannot find name 'jQuery'.
</code></pre>
<p>这时我们需要使用<code>declare var</code>来定义它的类型：</p>
<pre class="line-numbers"><code class="language-plain_text">declare var jQuery:(selector:string) =&gt; any;
jQuery('#foo')
</code></pre>
<p>上例中，<code>declare var</code> 并没有真的定义一个变量，只是定义了全局变量 <code>jQuery</code> 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是：</p>
<pre class="line-numbers"><code class="language-plain_text">jQuery('#foo')
</code></pre>
<p>除了 <code>declare var</code> 之外，还有其他很多种声明语句，将会在后面详细介绍。</p>
<h4><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是声明文件</h4>
<p>通常我们会把声明语句放到一个单独的文件（<code>jQuery.d.ts</code>）中，这就是声明文件：</p>
<pre class="line-numbers"><code class="language-plain_text">// src/jQuery.d.ts

declare var jQuery: (selector: string) =&gt; any;
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">// src/index.ts

jQuery('#foo');
</code></pre>
<p>声明文件必需以 <code>.d.ts</code> 为后缀。</p>
<p>一般来说，ts 会解析项目中所有的 <code>*.ts</code> 文件，当然也包含以 <code>.d.ts</code> 结尾的文件。所以当我们将 <code>jQuery.d.ts</code> 放到项目中时，其他所有 <code>*.ts</code> 文件就都可以获得 <code>jQuery</code> 的类型定义了。</p>
<p>假如仍然无法解析，那么可以检查下 <code>tsconfig.json</code> 中的 <code>files</code>、<code>include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p>
<h4><a id="%E7%AC%AC%E4%B8%89%E6%96%B9%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第三方声明文件</h4>
<p>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/jquery/index.d.ts">jQuery in DefinitelyTyped</a>。</p>
<p>我们可以直接下载下来使用，但是更推荐的是使用 <code>@types</code> 统一管理第三方库的声明文件。</p>
<p><code>@types</code> 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：</p>
<pre class="line-numbers"><code class="language-bash">npm install @types/jquery --save-dev
</code></pre>
<p>可以在<a href="https://microsoft.github.io/TypeSearch/">这个页面</a>搜索你需要的声明文件。</p>
<h4><a id="%E4%B9%A6%E5%86%99%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>书写声明文件</h4>
<p>在不同的场景下，声明文件的内容和使用方式会有所区别。</p>
<p>库的使用场景主要有以下几种：</p>
<ul>
<li>
<p>全局变量： 通过 <code>&lt;script&gt;</code> 标签引入第三方库，注入全局变量</p>
</li>
<li>
<p>npm包：通过 <code>import foo from 'foo'</code> 导入，符合 ES6 模块规范</p>
</li>
<li>
<p>UMD：既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 <code>import</code> 导入</p>
</li>
<li>
<p>直接扩展全局变量：通过 <code>&lt;script&gt;</code> 标签引入后，改变一个全局变量的结构</p>
</li>
<li>
<p>在npm包或UMD库中扩展全局变量： 引用 npm 包或 UMD 库后，改变一个全局变量的结构</p>
</li>
<li>
<p>模块插件：通过 <code>&lt;script&gt;</code> 或 <code>import</code> 导入后，改变另一个模块的结构</p>
</li>
</ul>
<h5><a id="%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全局变量</h5>
<p>全局变量是最简单的一种场景，之前举的例子就是通过 <code>&lt;script&gt;</code> 标签引入 jQuery，注入全局变量 <code>$</code> 和 <code>jQuery</code>。</p>
<p>使用全局变量的声明文件时，如果是以 <code>npm install @types/xxx --save-dev</code> 安装的，则不需要任何配置。如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 <code>src</code> 目录下（或者对应的源码目录下）：</p>
<pre class="line-numbers"><code class="language-plain_text">/path/to/project
├── src
|  ├── index.ts
|  └── jQuery.d.ts
└── tsconfig.json
</code></pre>
<p>如果没有生效，可以检查下 <code>tsconfig.json</code> 中的 <code>files</code>、<code>include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p>
<p>全局变量的声明文件主要有以下几种语法：</p>
<ul>
<li>declare var 声明全局变量</li>
<li>declare function 声明全局方法</li>
<li>declare class 声明全局类</li>
<li>declare enum 声明全局枚举类型</li>
<li>declare namespace 声明(含有子属性)全局对象</li>
<li>interface和type 声明全局类型</li>
</ul>
<h6><a id="declare-var" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>declare var</h6>
<p>在所有的声明语句中，<code>declare var</code> 是最简单的，如之前所学，它能够用来定义一个全局变量的类型。与其类似的，还有 <code>declare let</code> 和 <code>declare const</code>，使用 <code>let</code> 与使用 <code>var</code> 没有什么区别：</p>
<pre class="line-numbers"><code class="language-plain_text">// src/jQuery.d.ts

declare let jQuery: (selector: string) =&gt; any;
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">/ src/index.ts

jQuery('#foo');
// 使用 declare let 定义的 jQuery 类型，允许修改这个全局变量
jQuery = function(selector) {
    return document.querySelector(selector);
};
</code></pre>
<p>而当我们使用const定义时，标识此时的全局变量是一个常量，不允许再去修改它的值了</p>
<pre class="line-numbers"><code class="language-plain_text">// src/jQuery.d.ts

declare const jQuery: (selector: string) =&gt; any;

jQuery('#foo');
// 使用 declare const 定义的 jQuery 类型，禁止修改这个全局变量
jQuery = function(selector) {
    return document.querySelector(selector);
};
// ERROR: Cannot assign to 'jQuery' because it is a constant or a read-only property.
</code></pre>
<p>一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 <code>const</code> 而不是 <code>var</code> 或 <code>let</code>。</p>
<h6><a id="declare-function" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>declare function</h6>
<p><code>declare function</code> 用来定义全局函数的类型。jQuery 其实就是一个函数，所以也可以用 <code>function</code> 来定义：</p>
<pre class="line-numbers"><code class="language-plain_text">定义：declare function jQuery(selector: string): any;
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">使用：jQuery('#foo');
</code></pre>
<p>在函数类型的声明语句中，函数重载也是支持的<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/06-declare-function">6</a>：</p>
<pre class="line-numbers"><code class="language-plain_text">declare function jQuery(selector: string): any;
declare function jQuery(domReadyCallback: () =&gt; any): any;
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">jQuery('#foo');
jQuery(function() {
    alert('Dom Ready!');
});
</code></pre>
<p>需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/05-declare-jquery-value">5</a>：</p>
<pre class="line-numbers"><code class="language-plain_text">declare const jQuery = function(selector) {
    return document.querySelector(selector);
};
// ERROR: An implementation cannot be declared in ambient contexts.
</code></pre>
<h6><a id="declare-class" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>declare class</h6>
<p>当全局变量是一个类的时候，我们用 <code>declare class</code> 来定义它的类型</p>
<pre class="line-numbers"><code class="language-plain_text">// src/Animal.d.ts

declare class Animal {
    name: string;
    constructor(name: string);
    sayHi(): string;
}
// index.ts
let cat = new Animal('tom')
</code></pre>
<p>同样的，<code>declare class</code> 语句也只能用来定义类型，不能用来定义具体的实现，比如定义 <code>sayHi</code>方法的具体实现则会报错：</p>
<pre class="line-numbers"><code class="language-plain_text">declare class Animal {
    name: string;
    constructor(name: string);
    sayHi() {
        return `My name is ${this.name}`;
    };
    // ERROR: An implementation cannot be declared in ambient contexts.
}
</code></pre>
<h6><a id="declare-enum" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>declare enum</h6>
<p>使用 <code>declare enum</code> 定义的枚举类型也称作外部枚举（Ambient Enums）</p>
<pre class="line-numbers"><code class="language-plain_text">declare enum Directions {
    Up,
    Down,
    Left,
    Right
}
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];
</code></pre>
<p>与其他全局变量的类型声明一致，<code>declare enum</code> 仅用来定义类型，而不是具体的值。</p>
<p><code>Directions.d.ts</code> 仅仅会用于编译时的检查，声明文件里的内容在编译结果中会被删除。它编译结果是：</p>
<pre class="line-numbers"><code class="language-plain_text">var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];
</code></pre>
<p>其中 <code>Directions</code> 是由第三方库定义好的全局变量。</p>
<h6><a id="declare-namespace" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>declare namespace</h6>
<p>ES6中使用模块化，很少使用namespace</p>
<p><code>namespace</code> 被淘汰了，但是在声明文件中，<code>declare namespace</code> 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。</p>
<p>比如 <code>jQuery</code> 是一个全局变量，它是一个对象，提供了一个 <code>jQuery.ajax</code> 方法可以调用，那么我们就应该使用 <code>declare namespace jQuery</code> 来声明这个拥有多个子属性的全局变量。</p>
<pre class="line-numbers"><code class="language-plain_text">declare namespace jQuery {
    function ajax(url: string, settings?: any): void;
}
jQuery.ajax('/api/get_something');
</code></pre>
<p>注意，在 <code>declare namespace</code> 内部，我们直接使用 <code>function ajax</code> 来声明函数，而不是使用 <code>declare function ajax</code>。类似的，也可以使用 <code>const</code>, <code>class</code>, <code>enum</code> 等语句<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/09-declare-namespace">9</a>：</p>
<pre class="line-numbers"><code class="language-plain_text">declare namespace jQuery {
    function ajax(url: string, settings?: any): void;
    const version: number;
    class Event {
        blur(eventType: EventType): void
    }
    enum EventType {
        CustomClick
    }
}
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">jQuery.ajax('/api/get_something');
console.log(jQuery.version);
const e = new jQuery.Event();
e.blur(jQuery.EventType.CustomClick);
</code></pre>
<h6><a id="interface%E5%92%8Ctype" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>interface和type</h6>
<p>除了全局变量之外，可能有一些类型我们也希望能暴露出来。在类型声明文件中，我们可以直接使用 <code>interface</code> 或 <code>type</code> 来声明一个全局的接口或类型：</p>
<pre class="line-numbers"><code class="language-plain_text">interface AjaxSettings {
	meyhod?:'GET'|'POST'
	data?: any
}
declare namespace jQuery {
    function ajax(url: string, settings?: AjaxSettings): void;
}
</code></pre>
<p>这样的话，在其他文件中也可以使用这个接口或类型了：</p>
<pre class="line-numbers"><code class="language-plain_text">let settings: AjaxSettings = {
    method: 'POST',
    data: {
        name: 'foo'
    }
};
jQuery.ajax('/api/post_something', settings);
</code></pre>
<h6><a id="%E9%98%B2%E6%AD%A2%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>防止命名冲突</h6>
<p>暴露在最外层的 <code>interface</code> 或 <code>type</code> 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 <code>namespace</code> 下</p>
<pre class="line-numbers"><code class="language-plain_text">declare namespace jQuery {
    interface AjaxSettings {
        method?: 'GET' | 'POST'
        data?: any;
    }
    function ajax(url: string, settings?: AjaxSettings): void;
}
</code></pre>
<p>注意，在使用这个 <code>interface</code> 的时候，也应该加上 <code>jQuery</code> 前缀：</p>
<pre class="line-numbers"><code class="language-plain_text">let settings: jQuery.AjaxSettings = {
    method: 'POST',
    data: {
        name: 'foo'
    }
};
jQuery.ajax('/api/post_something', settings);
</code></pre>
<h6><a id="%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>声明合并</h6>
<p>假如 jQuery 既是一个函数，可以直接被调用 <code>jQuery('#foo')</code>，又是一个对象，拥有子属性 <code>jQuery.ajax()</code>（事实确实如此），那么我们可以组合多个声明语句，它们会不冲突的合并起来：</p>
<pre class="line-numbers"><code class="language-plain_text">declare function jQuery(selector: string): any;
declare namespace jQuery {
    function ajax(url: string, settings?: any): void;
}
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">jQuery('#foo');
jQuery.ajax('/api/get_something');
</code></pre>
<h5><a id="npm%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>npm包</h5>
<p>一般我们通过 <code>import foo from 'foo'</code> 导入一个 npm 包，这是符合 ES6 模块规范的。</p>
<p>在我们尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方：</p>
<ol>
<li>与该 npm 包绑定在一起。判断依据是 <code>package.json</code> 中有 <code>types</code> 字段，或者有一个 <code>index.d.ts</code> 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。</li>
<li>发布到 <code>@types</code> 里。我们只需要尝试安装一下对应的 <code>@types</code> 包就知道是否存在该声明文件，安装命令是 <code>npm install @types/foo --save-dev</code>。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 <code>@types</code> 里了。</li>
</ol>
<p>假如以上两种方式都没有找到对应的声明文件，那么我们就需要自己为它写声明文件了。由于是通过 <code>import</code> 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案：</p>
<ol>
<li>创建一个 <code>node_modules/@types/foo/index.d.ts</code> 文件，存放 <code>foo</code> 模块的声明文件。这种方式不需要额外的配置，但是 <code>node_modules</code> 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。</li>
<li>创建一个 <code>types</code> 目录，专门用来管理自己写的声明文件，将 <code>foo</code> 的声明文件放到 <code>types/foo/index.d.ts</code> 中。这种方式需要配置下 <code>tsconfig.json</code> 中的 <code>paths</code> 和 <code>baseUrl</code> 字段。</li>
</ol>
<p>目录结构：</p>
<pre class="line-numbers"><code class="language-plain_text">/path/to/project
├── src
|  └── index.ts
├── types
|  └── foo
|     └── index.d.ts
└── tsconfig.json
</code></pre>
<p><code>tsconfig.json</code> 内容：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    &quot;compilerOptions&quot;: {
        &quot;module&quot;: &quot;commonjs&quot;,
        &quot;baseUrl&quot;: &quot;./&quot;,
        &quot;paths&quot;: {
            &quot;*&quot;: [&quot;types/*&quot;]
        }
    }
}
</code></pre>
<p>如此配置之后，通过 <code>import</code> 导入 <code>foo</code> 的时候，也会去 <code>types</code> 目录下寻找对应的模块的声明文件了。</p>
<p>注意 <code>module</code> 配置可以有很多种选项，不同的选项会影响模块的导入导出模式。这里我们使用了 <code>commonjs</code> 这个最常用的选项，后面的教程也都默认使用的这个选项。</p>
<p>不管采用了以上两种方式中的哪一种，我都<strong>强烈建议</strong>大家将书写好的声明文件（通过给第三方库发 pull request，或者直接提交到 <code>@types</code> 里）发布到开源社区中，享受了这么多社区的优秀的资源，就应该在力所能及的时候给出一些回馈。只有所有人都参与进来，才能让 ts 社区更加繁荣。</p>
<p>npm 包的声明文件主要有以下几种语法：</p>
<ul>
<li>export 导出变量</li>
<li>export namespace 导出（含有子属性的）对象</li>
<li>export default ES6默认导出</li>
<li>export =  commonjs导出模块</li>
</ul>
<h6><a id="export" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>export</h6>
<p>npm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 <code>declare</code>不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 <code>export</code> 导出，然后在使用方 <code>import</code> 导入后，才会应用到这些类型声明。</p>
<p><code>export</code> 的语法与普通的 ts 中的语法类似，区别仅在于声明文件中禁止定义具体的实现：</p>
<pre class="line-numbers"><code class="language-plain_text">export const name: string;
export function getName(): string;
export class Animal {
    constructor(name: string);
    sayHi(): string;
}
export enum Directions {
    Up,
    Down,
    Left,
    Right
}
export interface Options {
    data: any;
}
</code></pre>
<p>对应的导入和使用模块应该是这样：</p>
<pre class="line-numbers"><code class="language-plain_text">import { name, getName, Animal, Directions, Options } from 'foo';

console.log(name);
let myName = getName();
let cat = new Animal('Tom');
let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];
let options: Options = {
    data: {
        name: 'foo'
    }
};
</code></pre>
<h6><a id="%E6%B7%B7%E7%94%A8declare%E5%92%8Cexport" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>混用declare和export</h6>
<p>我们也可以使用 <code>declare</code> 先声明多个变量，最后再用 <code>export</code> 一次性导出。上例的声明文件可以等价的改写为：</p>
<pre class="line-numbers"><code class="language-plain_text">eclare const name: string;
declare function getName(): string;
declare class Animal {
    constructor(name: string);
    sayHi(): string;
}
declare enum Directions {
    Up,
    Down,
    Left,
    Right
}
interface Options {
    data: any;
}

export { name, getName, Animal, Directions, Options };
</code></pre>
<p>注意，与全局变量的声明文件类似，<code>interface</code> 前是不需要 <code>declare</code> 的。</p>
<h6><a id="export-namespace" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>export namespace</h6>
<p>与 <code>declare namespace</code> 类似，<code>export namespace</code> 用来导出一个拥有子属性的对象</p>
<pre class="line-numbers"><code class="language-plain_text">export namespace foo {
    const name: string;
    namespace bar {
        function baz(): string;
    }
}
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">import { foo } from 'foo';

console.log(foo.name);
foo.bar.baz();
</code></pre>
<h6><a id="export-default" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>export default</h6>
<p>在 ES6 模块系统中，使用 <code>export default</code> 可以导出一个默认值，使用方可以用 <code>import foo from 'foo'</code> 而不是 <code>import { foo } from 'foo'</code> 来导入这个默认值。</p>
<p>在类型声明文件中，<code>export default</code> 用来导出默认值的类型：</p>
<pre class="line-numbers"><code class="language-plain_text">export default function foo(): string;
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">import foo from 'foo';

foo();
</code></pre>
<p>注意，只有 <code>function</code>、<code>class</code> 和 <code>interface</code> 可以直接默认导出，其他的变量需要先定义出来，再默认导出：</p>
<pre class="line-numbers"><code class="language-plain_text">export default enum Directions {
// ERROR: Expression expected.
    Up,
    Down,
    Left,
    Right
}
// error
</code></pre>
<p>上例中 <code>export default enum</code> 是错误的语法，需要使用 <code>declare enum</code> 定义出来，然后使用 <code>export default</code> 导出</p>
<pre class="line-numbers"><code class="language-plain_text">declare enum Directions {
    Up,
    Down,
    Left,
    Right
}

export default Directions;
</code></pre>
<p>针对这种默认导出，我们一般会将导出语句放在整个声明文件的最前面：</p>
<pre class="line-numbers"><code class="language-plain_text">export default Directions;

declare enum Directions {
    Up,
    Down,
    Left,
    Right
}
</code></pre>
<h6><a id="export" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>export=</h6>
<p>在 commonjs 规范中，我们用以下方式来导出一个模块：</p>
<pre class="line-numbers"><code class="language-plain_text">// 整体导出
module.exports = foo;
// 单个导出
exports.bar = bar;
</code></pre>
<p>在 ts 中，针对这种模块导出，有多种方式可以导入，第一种方式是 <code>const ... = require</code>：</p>
<pre class="line-numbers"><code class="language-plain_text">// 整体导入
const foo = require('foo');
// 单个导入
const bar = require('foo').bar;
</code></pre>
<p>第二种方式是 <code>import ... from</code>，注意针对整体导出，需要使用 <code>import * as</code> 来导入：</p>
<pre class="line-numbers"><code class="language-plain_text">// 整体导入
import * as foo from 'foo';
// 单个导入
import { bar } from 'foo';
</code></pre>
<p>第三种方式是 <code>import ... require</code>，这也是 ts 官方推荐的方式：</p>
<pre class="line-numbers"><code class="language-plain_text">// 整体导入
import foo = require('foo');
// 单个导入
import bar = foo.bar;
</code></pre>
<p>对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 <code>export =</code> 这种语法了<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/21-export-equal">21</a>：</p>
<pre class="line-numbers"><code class="language-plain_text">// types/foo/index.d.ts

export = foo;

declare function foo(): string;
declare namespace foo {
    const bar: number;
}
</code></pre>
<p>需要注意的是，上例中使用了 <code>export =</code> 之后，就不能再单个导出 <code>export { bar }</code> 了。所以我们通过声明合并，使用 <code>declare namespace foo</code>来将 <code>bar</code> 合并到 <code>foo</code> 里。</p>
<p>准确地讲，<code>export =</code> 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，<code>import ... require</code> 和 <code>export =</code> 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用，所以这里就不详细介绍了，感兴趣的可以看<a href="https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require">官方文档</a>。</p>
<p>由于很多第三方库是 commonjs 规范的，所以声明文件也就不得不用到 <code>export =</code> 这种语法了。但是还是需要再强调下，相比与 <code>export =</code>，我们更推荐使用 ES6 标准的 <code>export default</code> 和 <code>export</code>。</p>
<h5><a id="umd%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>UMD库</h5>
<p>既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 <code>import</code> 导入的库，称为 UMD 库。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供了一个新语法 <code>export as namespace</code>。</p>
<h6><a id="export-as-namespace" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>export as namespace</h6>
<p>一般使用 <code>export as namespace</code> 时，都是先有了 npm 包的声明文件，再基于它添加一条 <code>export as namespace</code> 语句，即可将声明好的一个变量声明为全局变量，举例如下：</p>
<pre class="line-numbers"><code class="language-plain_text">export as namespace foo;
export = foo;

declare function foo(): string;
declare namespace foo {
    const bar: number;
}
</code></pre>
<p>当然它也可以与 <code>export default</code> 一起使用：</p>
<pre class="line-numbers"><code class="language-plain_text">export as namespace foo;
export default foo;

declare function foo(): string;
declare namespace foo {
    const bar: number;
}
</code></pre>
<h5><a id="%E7%9B%B4%E6%8E%A5%E6%89%A9%E5%B1%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>直接扩展全局变量</h5>
<p>有的第三方库扩展了一个全局变量，可是此全局变量的类型却没有相应的更新过来，就会导致 ts 编译错误，此时就需要扩展全局变量的类型。比如扩展 <code>String</code> 类型</p>
<pre class="line-numbers"><code class="language-plain_text">interface String {
    prependHello(): string;
}

'foo'.prependHello();
</code></pre>
<p>通过声明合并，使用 <code>interface String</code> 即可给 <code>String</code> 添加属性或方法。</p>
<p>也可以使用 <code>declare namespace</code> 给已有的命名空间添加类型声明<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/24-merge-global-namespace">24</a>：</p>
<pre class="line-numbers"><code class="language-plain_text">// types/jquery-plugin/index.d.ts

declare namespace JQuery {
    interface CustomOptions {
        bar: string;
    }
}

interface JQueryStatic {
    foo(options: JQuery.CustomOptions): string;
}

</code></pre>
<pre class="line-numbers"><code class="language-plain_text">// src/index.ts

jQuery.foo({
    bar: ''
});
</code></pre>
<h5><a id="%E5%9C%A8npm%E5%8C%85%E6%88%96-umd%E5%BA%93%E4%B8%AD%E6%89%A9%E5%B1%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在 npm 包或 UMD 库中扩展全局变量</h5>
<p>如之前所说，对于一个 npm 包或者 UMD 库的声明文件，只有 <code>export</code> 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 <code>declare global</code></p>
<pre class="line-numbers"><code class="language-plain_text">declare global {
    interface String {
        prependHello(): string;
    }
}

export {};
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">'bar'.prependHello();
</code></pre>
<p>注意即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。</p>
<h5><a id="%E6%A8%A1%E5%9D%97%E6%8F%92%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模块插件</h5>
<p>有时通过 <code>import</code> 导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 <code>declare module</code>，它可以用来扩展原有模块的类型。</p>
<h6><a id="declare-module" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>declare module</h6>
<p>如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用 <code>declare module</code> 扩展原有模块</p>
<pre class="line-numbers"><code class="language-plain_text">import * as moment from 'moment';

declare module 'moment' {
    export function foo(): moment.CalendarKey;
}
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">import * as moment from 'moment';
import 'moment-plugin';

moment.foo();
</code></pre>
<p><code>declare module</code> 也可用于在一个文件中一次性声明多个模块的类型</p>
<pre class="line-numbers"><code class="language-plain_text">declare module 'foo' {
    export interface Foo {
        foo: string;
    }
}

declare module 'bar' {
    export function bar(): string;
}
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">import { Foo } from 'foo';
import * as bar from 'bar';

let f: Foo;
bar.bar();
</code></pre>
<h5><a id="%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>声明文件中的依赖</h5>
<p>一个声明文件有时会依赖另一个声明文件中的类型，比如在前面的 <code>declare module</code> 的例子中，我们就在声明文件中导入了 <code>moment</code>，并且使用了 <code>moment.CalendarKey</code> 这个类型：</p>
<pre class="line-numbers"><code class="language-plain_text">import * as moment from 'moment';

declare module 'moment' {
    export function foo(): moment.CalendarKey;
}
</code></pre>
<p>除了可以在声明文件中通过 <code>import</code> 导入另一个声明文件中的类型之外，还有一个语法也可以用来导入另一个声明文件，那就是三斜线指令。</p>
<h6><a id="%E4%B8%89%E6%96%9C%E7%BA%BF%E6%8C%87%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三斜线指令</h6>
<p>与 <code>namespace</code> 类似，三斜线指令也是 ts 在早期版本中为了描述模块之间的依赖关系而创造的语法。随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的三斜线指令来声明模块之间的依赖关系了。</p>
<p>但是在声明文件中，它还是有一定的用武之地。</p>
<p>类似于声明文件中的 <code>import</code>，它可以用来导入另一个声明文件。与 <code>import</code> 的区别是，当且仅当在以下几个场景下，我们才需要使用三斜线指令替代 <code>import</code>：</p>
<ul>
<li>当我们在<strong>书写</strong>一个全局变量的声明文件时</li>
<li>当我们需要<strong>依赖</strong>一个全局变量的声明文件时</li>
</ul>
<h6><a id="%E4%B9%A6%E5%86%99%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>书写</strong>一个全局变量的声明文件</h6>
<p>这些场景听上去很拗口，但实际上很好理解——在全局变量的声明文件中，是不允许出现 <code>import</code>, <code>export</code> 关键字的。一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。故当我们在书写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了</p>
<pre class="line-numbers"><code class="language-plain_text">/// &lt;reference types=&quot;jquery&quot; /&gt;
declare function foo(options: JQuery.AjaxSettings): string;
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">foo({});
</code></pre>
<p>三斜线指令的语法如上，<code>///</code> 后面使用 xml 的格式添加了对 <code>jquery</code> 类型的依赖，这样就可以在声明文件中使用 <code>JQuery.AjaxSettings</code> 类型了。</p>
<p>注意，三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释。</p>
<h6><a id="%E4%BE%9D%E8%B5%96%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>依赖一个全局变量的声明文件</h6>
<p>在另一个场景下，当我们需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 <code>import</code> 导入，当然也就必须使用三斜线指令来引入了</p>
<pre class="line-numbers"><code class="language-plain_text">/// &lt;reference types=&quot;node&quot; /&gt;

export function foo(p: NodeJS.Process): string;
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">import { foo } from 'node-plugin';

foo(global.process);
</code></pre>
<p>在上面的例子中，我们通过三斜线指引入了 <code>node</code> 的类型，然后在声明文件中使用了 <code>NodeJS.Process</code> 这个类型。最后在使用到 <code>foo</code> 的时候，传入了 <code>node</code> 中的全局变量 <code>process</code>。</p>
<p>由于引入的 <code>node</code> 中的类型都是全局变量的类型，它们是没有办法通过 <code>import</code> 来导入的，所以这种场景下也只能通过三斜线指令来引入了。</p>
<p>以上两种使用场景下，都是由于需要书写或需要依赖全局变量的声明文件，所以必须使用三斜线指令。在其他的一些不是必要使用三斜线指令的情况下，就都需要使用 <code>import</code> 来导入。</p>
<h6><a id="%E6%8B%86%E5%88%86%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拆分声明文件</h6>
<p>当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。比如 <code>jQuery</code> 的声明文件就是这样的：</p>
<pre class="line-numbers"><code class="language-plain_text">// node_modules/@types/jquery/index.d.ts

/// &lt;reference types=&quot;sizzle&quot; /&gt;
/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;
/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;
/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;
/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;

export = jQuery;
</code></pre>
<p>其中用到了 <code>types</code> 和 <code>path</code> 两种不同的指令。它们的区别是：<code>types</code> 用于声明对另一个库的依赖，而 <code>path</code> 用于声明对另一个文件的依赖。</p>
<p>上例中，<code>sizzle</code> 是与 <code>jquery</code> 平行的另一个库，所以需要使用 <code>types=&quot;sizzle&quot;</code> 来声明对它的依赖。而其他的三斜线指令就是将 <code>jquery</code> 的声明拆分到不同的文件中了，然后在这个入口文件中使用 <code>path=&quot;foo&quot;</code> 将它们一一引入。</p>
<h5><a id="%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自动生成声明文件</h5>
<p>如果库的源码本身就是由 ts 写的，那么在使用 <code>tsc</code> 脚本将 ts 编译为 js 的时候，添加 <code>declaration</code> 选项，就可以同时也生成 <code>.d.ts</code> 声明文件了。</p>
<p>我们可以在命令行中添加 <code>--declaration</code>（简写 <code>-d</code>），或者在 <code>tsconfig.json</code> 中添加 <code>declaration</code> 选项。这里以 <code>tsconfig.json</code> 为例：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    &quot;compilerOptions&quot;: {
        &quot;module&quot;: &quot;commonjs&quot;,
        &quot;outDir&quot;: &quot;lib&quot;,
        &quot;declaration&quot;: true,
    }
}
</code></pre>
<p>上例中我们添加了 <code>outDir</code> 选项，将 ts 文件的编译结果输出到 <code>lib</code> 目录下，然后添加了 <code>declaration</code> 选项，设置为 <code>true</code>，表示将会由 ts 文件自动生成 <code>.d.ts</code> 声明文件，也会输出到 <code>lib</code> 目录下。</p>
<p>运行 <code>tsc</code> 之后，目录结构如下:</p>
<pre class="line-numbers"><code class="language-plain_text">├── lib
|  ├── bar
|  |  ├── index.d.ts
|  |  └── index.js
|  ├── index.d.ts
|  └── index.js
├── src
|  ├── bar
|  |  └── index.ts
|  └── index.ts
├── package.json
└── tsconfig.json
</code></pre>
<p>在这个例子中，<code>src</code> 目录下有两个 ts 文件，分别是 <code>src/index.ts</code> 和 <code>src/bar/index.ts</code>，它们被编译到 <code>lib</code> 目录下的同时，也会生成对应的两个声明文件 <code>lib/index.d.ts</code> 和 <code>lib/bar/index.d.ts</code>。它们的内容分别是:</p>
<pre class="line-numbers"><code class="language-plain_text">// src/index.ts
export * from './bar';

export default function foo() {
    return 'foo';
}
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">// src/bar/index.ts
export function bar() {
    return 'bar';
}
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">// lib/index.d.ts

export * from './bar';
export default function foo(): string;
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">// lib/bar/index.d.ts

export declare function bar(): string;
</code></pre>
<p>可见，自动生成的声明文件基本保持了源码的结构，而将具体实现去掉了，生成了对应的类型声明。</p>
<p>使用 <code>tsc</code> 自动生成声明文件时，每个 ts 文件都会对应一个 <code>.d.ts</code> 声明文件。这样的好处是，使用方不仅可以在使用 <code>import foo from 'foo'</code> 导入默认的模块时获得类型提示，还可以在使用 <code>import bar from 'foo/lib/bar'</code> 导入一个子模块时，也获得对应的类型提示。</p>
<p>除了 <code>declaration</code> 选项之外，还有几个选项也与自动生成声明文件有关，这里只简单列举出来，不做详细演示了：</p>
<ul>
<li><code>declarationDir</code> 设置生成 <code>.d.ts</code> 文件的目录</li>
<li><code>declarationMap</code> 对每个 <code>.d.ts</code> 文件，都生成对应的 <code>.d.ts.map</code>（sourcemap）文件</li>
<li><code>emitDeclarationOnly</code> 仅生成 <code>.d.ts</code> 文件，不生成 <code>.js</code> 文件</li>
</ul>
<h4><a id="%E5%8F%91%E5%B8%83%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发布声明文件</h4>
<p>当我们为一个库写好了声明文件之后，下一步就是将它发布出去了。</p>
<p>此时有两种方案：</p>
<ol>
<li>将声明文件和源码放在一起</li>
<li>将声明文件发布到 <code>@types</code> 下</li>
</ol>
<p>这两种方案中优先选择第一种方案。保持声明文件与源码在一起，使用时就不需要额外增加单独的声明文件库的依赖了，而且也能保证声明文件的版本与源码的版本保持一致。</p>
<p>仅当我们在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request 时，才需要使用第二种方案，将声明文件发布到 <code>@types</code> 下。</p>
<h5><a id="%E5%B0%86%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E5%92%8C%E6%BA%90%E7%A0%81%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>将声明文件和源码放在一起</h5>
<p>如果声明文件是通过 <code>tsc</code> 自动生成的，那么无需做任何其他配置，只需要把编译好的文件也发布到 npm 上，使用方就可以获取到类型提示了。</p>
<p>如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别：</p>
<ul>
<li>给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址</li>
<li>在项目根目录下，编写一个 <code>index.d.ts</code> 文件</li>
<li>针对入口文件（<code>package.json</code> 中的 <code>main</code> 字段指定的入口文件），编写一个同名不同后缀的 <code>.d.ts</code> 文件</li>
</ul>
<p>第一种方式是给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址。比如：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    &quot;name&quot;: &quot;foo&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;main&quot;: &quot;lib/index.js&quot;,
    &quot;types&quot;: &quot;foo.d.ts&quot;,
}
</code></pre>
<p>指定了 <code>types</code> 为 <code>foo.d.ts</code> 之后，导入此库的时候，就会去找 <code>foo.d.ts</code> 作为此库的类型声明文件了。</p>
<p><code>typings</code> 与 <code>types</code> 一样，只是另一种写法。</p>
<p>如果没有指定 <code>types</code> 或 <code>typings</code>，那么就会在根目录下寻找 <code>index.d.ts</code> 文件，将它视为此库的类型声明文件。</p>
<p>如果没有找到 <code>index.d.ts</code> 文件，那么就会寻找入口文件（<code>package.json</code> 中的 <code>main</code> 字段指定的入口文件）是否存在对应同名不同后缀的 <code>.d.ts</code> 文件。</p>
<p>比如 <code>package.json</code> 是这样时：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    &quot;name&quot;: &quot;foo&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;main&quot;: &quot;lib/index.js&quot;
}
</code></pre>
<p>就会先识别 <code>package.json</code> 中是否存在 <code>types</code> 或 <code>typings</code> 字段。发现不存在，那么就会寻找是否存在 <code>index.d.ts</code> 文件。如果还是不存在，那么就会寻找是否存在 <code>lib/index.d.ts</code> 文件。假如说连 <code>lib/index.d.ts</code> 都不存在的话，就会被认为是一个没有提供类型声明文件的库了。</p>
<p>有的库为了支持导入子模块，比如 <code>import bar from 'foo/lib/bar'</code>，就需要额外再编写一个类型声明文件 <code>lib/bar.d.ts</code> 或者 <code>lib/bar/index.d.ts</code>，这与自动生成声明文件类似，一个库中同时包含了多个类型声明文件。</p>
<h5><a id="%E5%B0%86%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E5%8F%91%E5%B8%83%E5%88%B0types%E4%B8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>将声明文件发布到@types下</h5>
<p>如果我们是在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request，那么就需要将声明文件发布到 <code>@types</code> 下。</p>
<p>与普通的 npm 模块不同，<code>@types</code> 是统一由 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/">DefinitelyTyped</a> 管理的。要将声明文件发布到 <code>@types</code> 下，就需要给 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/">DefinitelyTyped</a> 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 <code>tsconfig.json</code> 等。</p>
<p>pull-request 需要符合它们的规范，并且通过测试，才能被合并，稍后就会被自动发布到 <code>@types</code> 下。</p>
<h3><a id="%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内置对象</h3>
<p>JavaScript有很多内置对象，它们可以直接在TypeScript中当做定义好了的类型</p>
<p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p>
<h4><a id="ecmascript%E7%9A%84%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ECMAScript的内置对象</h4>
<p>ECMAScript 标准提供的内置对象有：</p>
<p><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等。</p>
<p>我们可以在 TypeScript 中将变量定义为这些类型：</p>
<pre class="line-numbers"><code class="language-plain_text">let b: Boolean = new Boolean(1);
let e: Error = new Error('Error occurred');
let d: Date = new Date();
let r: RegExp = /[a-z]/;
</code></pre>
<h4><a id="dom%E5%92%8Cbom%E7%9A%84%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DOM和BOM的内置对象</h4>
<p>DOM 和 BOM 提供的内置对象有：</p>
<p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p>
<p>TypeScript 中会经常用到这些类型：</p>
<pre class="line-numbers"><code class="language-ts">let body: HTMLElement = document.body;
let allDiv: NodeList = document.querySelectorAll('div');
document.addEventListener('click', function(e: MouseEvent) {
  // Do something
});
</code></pre>
<h4><a id="typescript%E6%A0%B8%E5%BF%83%E5%BA%93%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeScript 核心库的定义文件</h4>
<p><a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库的定义文件</a>中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。</p>
<p>当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如：</p>
<pre class="line-numbers"><code class="language-plain_text">Math.pow(10, '2');
// index.ts(1,14): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
</code></pre>
<p>上面的例子中，<code>Math.pow</code> 必须接受两个 <code>number</code> 类型的参数。事实上 <code>Math.pow</code> 的类型定义如下：</p>
<pre class="line-numbers"><code class="language-plain_text">interface Math {
    /**
     * Returns the value of a base expression taken to a specified power.
     * @param x The base value of the expression.
     * @param y The exponent value of the expression.
     */
    pow(x: number, y: number): number;
}
</code></pre>
<p>再举一个 DOM 中的例子：</p>
<pre class="line-numbers"><code class="language-ts">document.addEventListener('click', function(e) {
    console.log(e.targetCurrent);
});

// index.ts(2,17): error TS2339: Property 'targetCurrent' does not exist on type 'MouseEvent'.
</code></pre>
<p>上面的例子中，<code>addEventListener</code> 方法是在 TypeScript 核心库中定义的：</p>
<pre class="line-numbers"><code class="language-ts">interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent {
    addEventListener(type: string, listener: (ev: MouseEvent) =&gt; any, useCapture?: boolean): void;
}
</code></pre>
<p>所以 <code>e</code> 被推断成了 <code>MouseEvent</code>，而 <code>MouseEvent</code> 是没有 <code>targetCurrent</code> 属性的，所以报错了。</p>
<p>注意，TypeScript 核心库的定义中不包含 Node.js 部分。</p>
<h4><a id="%E7%94%A8typescript%E5%86%99-node-js" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用 TypeScript 写 Node.js</h4>
<p>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：</p>
<pre class="line-numbers"><code class="language-plain_text">npm install @types/node --save-dev
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Http请求中Content-Type]]></title>
    <link href="https://www.bwrong.cn/17280335710035.html"/>
    <updated>2024-10-04T17:19:30+08:00</updated>
    <id>https://www.bwrong.cn/17280335710035.html</id>
    <content type="html"><![CDATA[
<ol>
<li><strong>Content-Type</strong></li>
</ol>
<p>MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。</p>
<pre class="line-numbers"><code class="language-plain_text">1. 类型格式：type/subtype(;parameter)? type 
2. 主类型，任意的字符串，如text，如果是*号代表所有；  
3. subtype 子类型，任意的字符串，如html，如果是*号代表所有；  
4. parameter 可选，一些参数，如Accept请求头的q参数， Content-Type的 charset参数。  
</code></pre>
<p>例如： <code>Content-Type: text/html;charset:utf-8;</code></p>
<p>常见的媒体格式类型如下：</p>
<ul>
<li>text/html ： HTML格式</li>
<li>text/plain ：纯文本格式</li>
<li>text/xml ： XML格式</li>
<li>image/gif ：gif图片格式</li>
<li>image/jpeg ：jpg图片格式</li>
<li>image/png：png图片格式</li>
</ul>
<p>以application开头的媒体格式类型：</p>
<ul>
<li>application/xhtml+xml ：XHTML格式</li>
<li>application/xml   ： XML数据格式</li>
<li>application/atom+xml ：Atom XML聚合格式</li>
<li>application/json  ： JSON数据格式</li>
<li>application/pdf    ：pdf格式</li>
<li>application/msword ： Word文档格式</li>
<li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li>
<li>application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li>
</ul>
<p>另外一种常见的媒体格式是上传文件之时使用的：</p>
<ul>
<li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li>
</ul>
<p>以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。</p>
<ol start="2">
<li><strong>Spring MVC中关于关于Content-Type类型信息的使用</strong></li>
</ol>
<p>首先我们来看看RequestMapping中的Class定义：</p>
<pre class="line-numbers"><code class="language-java">@Target({ElementType.METHOD, ElementType.TYPE}) 
@Retention(RetentionPolicy.RUNTIME) 
@Documented 
@Mapping 
public @interface RequestMapping { 
	String[] value() default {};
	RequestMethod[] method() default {}; 
	String[] params() default {}; 
	String[] headers() default {};
	String[] consumes() default {};
	String[] produces() default {}; 
} 
</code></pre>
<p>value: 指定请求的实际地址， 比如 /action/info之类。<br />
method： 指定请求的method类型， GET、POST、PUT、DELETE等<br />
consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;<br />
produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回<br />
params： 指定request中必须包含某些参数值是，才让该方法处理<br />
headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求</p>
<p>其中，consumes， produces使用content-typ信息进行过滤信息；headers中可以使用content-type进行过滤和判断。</p>
<ol start="3">
<li><strong>使用示例</strong></li>
</ol>
<p>3.1 headers</p>
<pre class="line-numbers"><code class="language-java">@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET, headers=&quot;Referer=http://www.ifeng.com/&quot;)  
public void testHeaders(@PathVariable String ownerId, @PathVariable String petId) {    
	// implementation omitted  
}  
</code></pre>
<p>这里的Headers里面可以匹配所有Header里面可以出现的信息，不局限在Referer信息。</p>
<p>示例2</p>
<pre class="line-numbers"><code class="language-java">@RequestMapping(value = &quot;/response/ContentType&quot;, headers = &quot;Accept=application/json&quot;)    
public void response2(HttpServletResponse response) throws IOException {    
    //表示响应的内容区数据的媒体类型为json格式，且编码为utf-8(客户端应该以utf-8解码)    
    response.setContentType(&quot;application/json;charset=utf-8&quot;);    
    //写出响应体内容    
    String jsonData = &quot;{\&quot;username\&quot;:\&quot;zhang\&quot;, \&quot;password\&quot;:\&quot;123\&quot;}&quot;;    
    response.getWriter().write(jsonData);    
}    
</code></pre>
<p>服务器根据请求头“Accept=application/json”生产json数据。</p>
<p>当你有如下Accept头，将遵守如下规则进行应用：<br />
①Accept：<code>text/html,application/xml,application/json</code><br />
将按照如下顺序进行produces的匹配 ①text/html ②application/xml ③application/json<br />
②Accept：<code>application/xml;q=0.5,application/json;q=0.9,text/html</code><br />
将按照如下顺序进行produces的匹配 ①text/html ②application/json ③application/xml<br />
参数为媒体类型的质量因子，越大则优先权越高(从0到1)<br />
③Accept：<em><code>/*,text/*,text/html</code><br />
将按照如下顺序进行produces的匹配 ①text/html ②text/</em> ③*/*</p>
<p>即匹配规则为：最明确的优先匹配。</p>
<h2><a id="requests%E9%83%A8%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Requests部分</h2>
<table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>指定客户端能够接收的内容类型</td>
<td>Accept: text/plain, text/html</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可以接受的字符编码集。</td>
<td>Accept-Charset: iso-8859-5</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>
<td>Accept-Encoding: compress, gzip</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可接受的语言</td>
<td>Accept-Language: en,zh</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>可以请求网页实体的一个或者多个子范围字段</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Authorization</td>
<td>HTTP授权的授权证书</td>
<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>指定请求和响应遵循的缓存机制</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>
<td>Connection: close</td>
</tr>
<tr>
<td>Cookie</td>
<td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>
<td>Cookie: $Version=1; Skin=new;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求的内容长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求的与实体对应的MIME信息</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
</tr>
<tr>
<td>Date</td>
<td>请求发送的日期和时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>Expect</td>
<td>请求的特定的服务器行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>From</td>
<td>发出请求的用户的Email</td>
<td>From: <a href="mailto:user@email.com">user@email.com</a></td>
</tr>
<tr>
<td>Host</td>
<td>指定请求的服务器的域名和端口号</td>
<td>Host: <a href="http://www.zcmhi.com">www.zcmhi.com</a></td>
</tr>
<tr>
<td>If-Match</td>
<td>只有请求内容与实体相匹配才有效</td>
<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>
<td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>
<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>只在实体在指定时间之后未被修改才请求成功</td>
<td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制信息通过代理和网关传送的时间</td>
<td>Max-Forwards: 10</td>
</tr>
<tr>
<td>Pragma</td>
<td>用来包含实现特定的指令</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>连接到代理的授权证书</td>
<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Range</td>
<td>只请求实体的一部分，指定范围</td>
<td>Range: bytes=500-999</td>
</tr>
<tr>
<td>Referer</td>
<td>先前网页的地址，当前请求网页紧随其后,即来路</td>
<td>Referer: <a href="http://www.zcmhi.com/archives/71.html">http://www.zcmhi.com/archives/71.html</a></td>
</tr>
<tr>
<td>TE</td>
<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>
<td>TE: trailers,deflate;q=0.5</td>
</tr>
<tr>
<td>Upgrade</td>
<td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
</tr>
<tr>
<td>User-Agent</td>
<td>User-Agent的内容包含发出请求的用户信息</td>
<td>User-Agent: Mozilla/5.0 (Linux; X11)</td>
</tr>
<tr>
<td>Via</td>
<td>通知中间网关或代理服务器地址，通信协议</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>关于消息实体的警告信息</td>
<td>Warn: 199 Miscellaneous warning</td>
</tr>
</tbody>
</table>
<h2><a id="responses%E9%83%A8%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Responses 部分</h2>
<table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Age</td>
<td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
<td>Age: 12</td>
</tr>
<tr>
<td>Allow</td>
<td>对某网络资源的有效的请求行为，不允许则返回405</td>
<td>Allow: GET, HEAD</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>web服务器支持的返回内容压缩编码类型。</td>
<td>Content-Encoding: gzip</td>
</tr>
<tr>
<td>Content-Language</td>
<td>响应体的语言</td>
<td>Content-Language: en,zh</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应体的长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Location</td>
<td>请求资源可替代的备用的另一地址</td>
<td>Content-Location: /index.htm</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>返回资源的MD5校验值</td>
<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td>Content-Range</td>
<td>在整个返回体中本部分的字节位置</td>
<td>Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td>Content-Type</td>
<td>返回内容的MIME类型</td>
<td>Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td>Date</td>
<td>原始服务器消息发出的时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值</td>
<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>Expires</td>
<td>响应过期的日期和时间</td>
<td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
<td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
<tr>
<td>Location</td>
<td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>
<td>Location: <a href="http://www.zcmhi.com/archives/94.html">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Pragma</td>
<td>包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>它指出认证方案和可应用到代理的该URL上的参数</td>
<td>Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td>refresh</td>
<td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td>Refresh: 5; url=<a href="http://www.zcmhi.com/archives/94.html">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Retry-After</td>
<td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>
<td>Retry-After: 120</td>
</tr>
<tr>
<td>Server</td>
<td>web服务器软件名称</td>
<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置Http Cookie</td>
<td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>
</tr>
<tr>
<td>Trailer</td>
<td>指出头域在分块传输编码的尾部存在</td>
<td>Trailer: Max-Forwards</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>文件传输编码</td>
<td>Transfer-Encoding:chunked</td>
</tr>
<tr>
<td>Vary</td>
<td>告诉下游代理是使用缓存响应还是从原始服务器请求</td>
<td>Vary: *</td>
</tr>
<tr>
<td>Via</td>
<td>告知代理客户端响应是通过哪里发送的</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>警告实体可能存在的问题</td>
<td>Warning: 199 Miscellaneous warning</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>表明客户端请求实体应该使用的授权方案</td>
<td>WWW-Authenticate: Basic</td>
</tr>
</tbody>
</table>
<p>3.2 params的示例</p>
<pre class="line-numbers"><code class="language-java">@RequestMapping(value = &quot;/test/{userId}&quot;, method = RequestMethod.GET, params=&quot;myParam=myValue&quot;)    
public void findUser(@PathVariable String userId) {        
  // implementation omitted    
} 
</code></pre>
<p>仅处理请求中包含了名为“myParam”，值为“myValue”的请求，起到了一个过滤的作用。</p>
<p>3.3 consumes/produces</p>
<pre class="line-numbers"><code class="language-java">@Controller    
@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST, consumes=&quot;application/json&quot;, produces=&quot;application/json&quot;)    
@ResponseBody  
public List&lt;User&gt; addUser(@RequestBody User userl) {        
    // implementation omitted    
    return List&lt;User&gt; users;  
} 
</code></pre>
<p>方法仅处理request Content-Type为“application/json”类型的请求. produces标识==&gt;处理request请求中Accept头中包含了&quot;application/json&quot;的请求，同时暗示了返回的内容类型为application/json;</p>
<ol start="4">
<li><strong>总结</strong></li>
</ol>
<p>在本文中，首先介绍了Content-Type主要支持的格式内容，然后基于@RequestMapping标注的内容介绍了主要的使用方法，其中,headers, consumes,produces,都是使用Content-Type中使用的各种媒体格式内容，可以基于这个格式内容来进行访问的控制和过滤。</p>
<p>参考资料：</p>
<ol>
<li>HTTP中支持的Content-Type: <a href="http://tool.oschina.net/commons">http://tool.oschina.net/commons</a></li>
<li>Media Type介绍。 <a href="http://www.iteye.com/topic/1127120">http://www.iteye.com/topic/1127120</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP状态码详解]]></title>
    <link href="https://www.bwrong.cn/17280335390285.html"/>
    <updated>2024-10-04T17:18:59+08:00</updated>
    <id>https://www.bwrong.cn/17280335390285.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td>
</tr>
<tr>
<td>101</td>
<td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td>
</tr>
<tr>
<td>102</td>
<td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td>
</tr>
<tr>
<td>200</td>
<td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td>
</tr>
<tr>
<td>201</td>
<td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。</td>
</tr>
<tr>
<td>202</td>
<td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>
</tr>
<tr>
<td>203</td>
<td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td>
</tr>
<tr>
<td>204</td>
<td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>
</tr>
<tr>
<td>205</td>
<td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td>
</tr>
<tr>
<td>206</td>
<td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td>
</tr>
<tr>
<td>207</td>
<td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>
</tr>
<tr>
<td>300</td>
<td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td>
</tr>
<tr>
<td>301</td>
<td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td>
</tr>
<tr>
<td>302</td>
<td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td>
</tr>
<tr>
<td>303</td>
<td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td>
</tr>
<tr>
<td>304</td>
<td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td>
</tr>
<tr>
<td>305</td>
<td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td>
</tr>
<tr>
<td>306</td>
<td>在最新版的规范中，306状态码已经不再被使用。</td>
</tr>
<tr>
<td>307</td>
<td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td>
</tr>
<tr>
<td>400</td>
<td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。</td>
</tr>
<tr>
<td>401</td>
<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>
</tr>
<tr>
<td>402</td>
<td>该状态码是为了将来可能的需求而预留的。</td>
</tr>
<tr>
<td>403</td>
<td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>
</tr>
<tr>
<td>404</td>
<td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td>
</tr>
<tr>
<td>405</td>
<td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>
</tr>
<tr>
<td>406</td>
<td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>
</tr>
<tr>
<td>407</td>
<td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td>
</tr>
<tr>
<td>408</td>
<td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>
</tr>
<tr>
<td>409</td>
<td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>
</tr>
<tr>
<td>410</td>
<td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone'，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>
</tr>
<tr>
<td>411</td>
<td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>
</tr>
<tr>
<td>412</td>
<td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>
</tr>
<tr>
<td>413</td>
<td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>
</tr>
<tr>
<td>414</td>
<td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>
</tr>
<tr>
<td>415</td>
<td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>
</tr>
<tr>
<td>416</td>
<td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>
</tr>
<tr>
<td>417</td>
<td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>
</tr>
<tr>
<td>421</td>
<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td>422</td>
<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td>422</td>
<td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>424</td>
<td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>425</td>
<td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td>
</tr>
<tr>
<td>426</td>
<td>客户端应当切换到TLS/1.0。（RFC 2817）</td>
</tr>
<tr>
<td>449</td>
<td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>
</tr>
<tr>
<td>500</td>
<td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td>
</tr>
<tr>
<td>501</td>
<td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td>
</tr>
<tr>
<td>502</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td>
</tr>
<tr>
<td>503</td>
<td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td>
</tr>
<tr>
<td>504</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td>
</tr>
<tr>
<td>505</td>
<td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td>
</tr>
<tr>
<td>506</td>
<td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td>
</tr>
<tr>
<td>507</td>
<td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td>
</tr>
<tr>
<td>509</td>
<td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td>
</tr>
<tr>
<td>510</td>
<td>获取资源所需要的策略并没有没满足。（RFC 2774）</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】webgl技术风云录之BabylonJS]]></title>
    <link href="https://www.bwrong.cn/17280335013759.html"/>
    <updated>2024-10-04T17:18:21+08:00</updated>
    <id>https://www.bwrong.cn/17280335013759.html</id>
    <content type="html"><![CDATA[
<p>微软除了在BabylonJS上面布局，同时还投资blender，对未来3D技术布局非常明显。BabylonJS是世界上最强大、最惊艳、最易用的Web3D渲染引擎，并且我们坚持让它完全开源和免费，无论对任何人都如此。Babylon.js 4.1版本的体积小了3倍，速度提升了12%，并且进行了无数的性能优化，在它诞生的那一刻就定位于高性能3D引擎，即使功能越来越强大也会继续贯彻这个理念不动摇。新的Node Material Editor编辑器、真正跨平台的babylon原生应用部署体验、层叠阴影、导航寻路、更强的WebXR虚拟现实及增强现实支持、更完美的glTF格式支持等新功能，让Babylon.js 4.1成为了你不可或缺的web应用开发利器。</p>
<p>Babylonjs不光有微软强大的资金支持，同时它代码功能结构很多参考blender技术体系，如果你同时看了blender代码跟Babylonjs代码，你会发现很多地方都有共同点。</p>
<p>官网：</p>
<p><a href="%E2%80%8Bwww.babylonjs.com/">Babylon.js: Powerful, Beautiful, Simple, Open - Web-Based 3D At Its Best</a></p>
<p>它主要特性有以下几个方面：</p>
<p>1、强大的编辑器，这是threejs跟playcanvas无法比拟的。</p>
<p><figure><img src="media/17280335013759/17281439645359.png" alt="" /></figure></p>
<p>编辑器中，对粒子、碰撞、脚本、GUI、精灵图等等各方面功能集成得非常完善，作为一个多年使用微软IDE从事开发的码农，个人一直认为微软的东西很人性化。</p>
<p>2、强大的节点编辑器。在blender里面节点编辑器无处不在，它也是通过connect不同节点的input跟output来实现节点之间的数据联通，这样就把复杂的材质系统变成可视化了。</p>
<p>Node Material Editor是一个强大而易用的材质编辑器，它以可视化的拖拽节点的方式来模拟shader编程，从而为每个从业者解锁了GPU的强大威力。从前，shaders (GPU 编程)着色器编程对于普通程序员门槛很高，因为它过于偏向底层，虽然功能强大，但是晦涩难懂，而Babylon带来的Node Material Editor可以实现与shader同样的效果，但是界面化操作，把难度降到了最低。我们相信，每个人都能使用这个编辑器来创建令人惊叹的视觉效果。</p>
<p><figure><img src="media/17280335013759/17281439645382.png" alt="" /></figure><br />
材质节点</p>
<p><figure><img src="media/17280335013759/17281439645401.png" alt="" /></figure><br />
Babylonjs材质节点</p>
<p>3、NATIVE 跨平台原生应用部署。程序员们写代码都有一个梦想：一次编写实现，多平台共享运行。 所以我们重磅推出了Babylon Native，它可以用原有的Babylon.js代码在任意平台构建一个原生应用，充分释放本机设备的性能优势。 已经支持DirectX on Windows、 Metal on iOS/MacOS、 OpenGL on Android，即将推出Vulkan支持。</p>
<p>Babylonjs的原生打包部署是通过react native技术体系来实现的，这样就可以实现一份代码原生部署，同时保证原生性能。</p>
<p>4、支持先进的WEBXR技术。毫无疑问，在web使用AR/VR技术非常有前景，Babylon最新4.1版本在WebXR上做了进一步的优化和改进：带来了一个简单易用的体检帮助器，针对更高级用户的专用会话管理器，用babylon的相机功能来承载WebXR技术，全面支持任何接受WebXR会话的设备，完整的WebXR输入源支持，关于实验性AR功能、通信、场景交互、物理效果的整套API支持等。</p>
<p><figure><img src="media/17280335013759/17281439645428.png" alt="" /></figure><br />
webxr支持<br />
总结：</p>
<p>1、如果你要交付内部项目、而且可以是客户端、有U3D开发人员，那么用U3D去交付实现最好，通过安装exe客户端，灯光效果交互、vr支持都是非常完美，而且U3D的开发者论坛、文档、百度教程都非常丰富。</p>
<p>2、如果你项目必须是webgl的，需要浏览器打开，webgl技术风云录中提到的那些平台都无法满足你的需求，建议你用Babylonjs，这是最好的平台，最好的框架。</p>
<p><a href="%E2%80%8Bwww.zhihu.com/column/c_1327931812140441600">webGL技术风云录专栏</a></p>
<p>3、如果您是webgl开发者，你目前毫无头绪，请使用threejs，它是万金油</p>
<p>4、如果您是webgl方面创业公司，正在进行技术选型，请您选择BabylonJS，你要研发自己的模型展示交付平台或者是要研发自己的场景漫游系统，通过BabylonJS引擎、以及他的inspect和编辑器，你可以快速拿出自己的产品，而且产品质量还不低。最后你要做的是业务逻辑开发以及界面美化定制。</p>
<p>目前市面上很多模型展示交付平台，其实它内核部分都没少技术含量，大量是包装过度，如果您用BabylonJS可以快速组装搬运集成，别人一个团队10多个人几年时间，你可以在短短几个开发人员几个月之内追赶上，还可以超越。</p>
<p>下面这家公司使用的就是BabylonJS制作的云展，案例效果不错。</p>
<p><a href="%E2%80%8Bwww.cool360.com/">虚拟博物馆(cool360.com)-官网</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/341360474">查看原文</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】webgl技术风云录之盈利模式]]></title>
    <link href="https://www.bwrong.cn/17280334778925.html"/>
    <updated>2024-10-04T17:17:57+08:00</updated>
    <id>https://www.bwrong.cn/17280334778925.html</id>
    <content type="html"><![CDATA[
<p>作为从事webgl开发的工程师，不得不思考行业的趋势以及同行企业的盈利模式。如果从事游戏开发，不属于此范畴，作者不对游戏行业不够熟悉。目前接触到的webgl很多都是从事展示，更多卖的不是技术本身而是设计，其实就是模型、靠的是三维设计师的能力、赚得是三维设计师的血汗。</p>
<p>当然有些公司依然是靠webgl技术本身赚钱，而不是通过销售设计数据，目前无外乎如下几方面：</p>
<h2><a id="1%E3%80%81%E4%BC%A0%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B1%95%E8%A7%88%E5%85%AC%E5%8F%B8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、传统设计展览公司</h2>
<p>其实很多设计展厅公司都已经上市，他们有固定客户资源、三维设计师对行业专业程度非常高，所以他们通过线下展厅设计施工、加上U3D开发的一些数字互动功能，就可以快速交付项目。对他们来说，webgl意义不大，U3D已经足够，而且是非常好的技术方案，性能好、效果好、VR支持高，因为都是本地部署不要求跨终端浏览器访问。这些公司盈利点也是靠设计、施工、材料来实现利润增长。</p>
<h2><a id="2%E3%80%81720%E4%BA%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、720云</h2>
<p>720云其实满足了很多设计师全景图的快速交付，720云本身不参与数据制作，纯靠技术平台以及全景拍摄硬件来盈利。他能盈利是因为平台本身确实解决了用户痛点，而航拍、户外大场景全景拍摄、全景效果图交付这些需要一个全景展示平台来展示作品，720云经过这些年的沉淀推广，把这一个环节做得非常完善简便，所以它有存在的价值。</p>
<h2><a id="3%E3%80%81%E9%85%B7%E5%AE%B6%E4%B9%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、酷家乐</h2>
<p>酷家乐鼎鼎大名、80亿美金估值，短短几年时间不得不佩服，通过研究它前端代码结构、试用其产品、它的渲染速度、渲染效果都是令人非常满意。它重新定义了室内装修，让繁琐复杂、交付周期长的效果图制作大大缩短，同时降低设计师技术要求，通过模型库、户型图、渲染平台让整个流程一气呵成。webgl技术在它平台算重要的一环，其背后的渲染平台、以及后台架构更加重要，一整套技术成就了这个设计界的霸主。</p>
<h2><a id="4%E3%80%81style3d" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4、style3d</h2>
<p>如果你看见style3d的渲染视频，你会对他柔体建模以及展示佩服不已。三维中刚体最简单、柔体、流体、毛发是非常复杂的几大块，而style3d通过多年垂直领域的沉淀积累、技术打磨，让他成为了服装设计界的明星。它盈利天经地义。</p>
<h2><a id="5%E3%80%81%E5%AE%9D%E7%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5、宝珑</h2>
<p>宝珑珠宝设计，早期用的是flash，而且可以直接decomp其代码，在flash技术体系内，通过shader进行珠宝设计以及展示技术很厉害了。现在他们迎合技术发展趋势，因为flash在很多平台浏览器上支持都慢慢停止，所以他们珠宝设计、展示、定制都迁移到webgl上面，通过threejs进行深度定制来实现。珠宝设计领域，可以去试试他们产品，我有两个珠宝行业朋友，用得就是他们的技术。</p>
<h2><a id="6%E3%80%81matterport%E4%BC%97%E8%B6%A3%E8%B4%9D%E5%A3%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6、matterport &amp; 众趣 &amp;贝壳</h2>
<p>贝壳看房，世界杯轰炸一轮，连我退休的爸妈都知道贝壳看房，而这项技术的引领者应该就是matterport。其实在09年就有人做网上看房，那时候是基于flex，通过全景图或者简单的户型模型来实现，效果太差。matterport把整个体验重新定义，通过硬件线下采集照片以及深度数据，云端进行ai合成户型模型，然后展示端把全景图当纹理贴到户型模型上，让整个体验更加饱满、制作更加简单，而且是照片级1:1还原线下场景。这在看房领域真是福音，因为看房通过纯全景图krpano那种模式效果还是太差，不够身临其境，而matterport这在技术方案彻底解决了这一问题。</p>
<h2><a id="7%E3%80%81%E6%B7%98%E5%AE%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7、淘宝</h2>
<p>阿里在短视频跟直播方面应该没有跟上脚步、直播带货也是后期才追赶，但是三维他肯定不会错过。通过投资躺平设计家、研发ace-tiny、以及今年的几场云展、场景购，已经开始布局整个三维行业，三维对未来购物肯定是非常有意义的，很多商品需要三维才能更加完美展示细节，有些商品通过场景可以提升用户购物欲望。</p>
<p>总之：</p>
<p>可以发现不论什么技术，它必须跟场景结合，必须跟行业结合，必须落地业务逻辑，真正解决特点场景下的某些问题它才有意义。以前大数据，多少投资人血本无归，几千万或者上亿最后只剩下一个没什么人用的看板。如今webgl一样会有很多投资人血本无归，因为光技术本身很难赚钱，除非优化某个行业数据生产方式或者深耕某个行业、跟行业内老玩家联姻，深耕技术沉淀团队方能杀出一条血路。</p>
<p>今年疫情，导致无数个云展公司成立，通过百度推广以及阿里域名查询，就可以发现一大堆公司开始从事这一行业，很多是皮包公司，接单就转包。有些是通过720云直接交付全景图，象征性加入云展厅，因为成本最低。还有很多是传统设计公司，转型卖设计。其实在云展这个行业，卖得不是技术而是设计数据本身。</p>
<p>蝉三维，立足于免费、提供快速模型交付，高效率精简团队可以通过部分软件功能定制、平台定制养活自己，更重要的是技术的不断积累、行业解决方案日益沉淀，最后真正解决特定用户群体切身问题，盈利模式就可以非常清晰。</p>
<p><a href="https://zhuanlan.zhihu.com/p/341414739">查看原文</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转微前端4】qiankun扩展]]></title>
    <link href="https://www.bwrong.cn/17280334440663.html"/>
    <updated>2024-10-04T17:17:24+08:00</updated>
    <id>https://www.bwrong.cn/17280334440663.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>详细流程</h2>
<p><figure><img src="media/17280334440663/17281450820669.webP" alt="image.png" /><figcaption>image.png<figcaption></figure></p>
<p>简易流程：</p>
<ol>
<li>qiankun 会用 原生fetch方法，请求微应用的 entry 获取微应用资源，然后通过 response.text 把获取内容转为字符串。</li>
<li>将 HTML 字符串传入 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkuitos%2Fimport-html-entry%2Fblob%2F76df4b3737d54112f6bf2dfabcd01709079468e4%2Fsrc%2Fprocess-tpl.js%23L58">processTpl</a> 函数，进行 HTML 模板解析，通过正则匹配 HTML 中对应的 javaScript（内联、外联）、css（内联、外联）、代码注释、entry、ignore 收集并替换，去除 <code>html/head/body</code> 等标签，其他资源保持原样</li>
<li>将收集的 <code>styles</code> 外链URL对象通过 fetch 获取 css，并将 css 内容以 <code>&lt;style&gt;</code> 的方式替换到原来 link标签的位置</li>
<li>收集 script 外链对象，对于异步执行的 JavaScript 资源会打上 <code>async</code> 标识 ，会使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkuitos%2Fimport-html-entry%2Fblob%2F76df4b3737d54112f6bf2dfabcd01709079468e4%2Fsrc%2Findex.js%23L104">requestIdleCallback</a> 方法延迟执行。</li>
<li>接下来会创建一个匿名自执行函数包裹住获取到的 js 字符串，最后通过 eval 去创建一个执行上下文执行 js 代码，通过传入 proxy 改变 window 指向，完成 JavaScript 沙箱隔离。<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkuitos%2Fimport-html-entry%2Fblob%2F76df4b3737d54112f6bf2dfabcd01709079468e4%2Fsrc%2Findex.js%23L45">源码位置</a>。</li>
<li>由于 qiankun 是自执行函数执行微应用的 JavaScript，因此在加载后的微应用中是看不到 JavaScript 资源引用的，只有一个资源被执行替换的标识。</li>
<li>当一切准备就绪的时候，执行微应用的 JavaScript 代码，渲染出微应用</li>
</ol>
<h2><a id="%E6%9E%81%E9%99%90%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>极限应用场景</h2>
<ul>
<li>
<p>与路由绑定的方式渲染微应用</p>
<p>接入这类平台的微应用，通常只需要提供自己的 entry html 地址，并为其分配一个路由规则即可，会根据当前路由自动切换微应用加载。</p>
<p><figure><img src="media/17280334440663/17281450820693.jpg" alt="v2-c345f8bf9c8855176037f6b48e315caf_1440w" /><figcaption>v2-c345f8bf9c8855176037f6b48e315caf_1440w<figcaption></figure></p>
</li>
<li>
<p>以组件的方式使用微应用</p>
<p><video controls height='100%' width='100%' src="media/17280334440663/20220331164434.mp4"></video></p>
<p>开发者可以在脱离路由的限制下，以更自由的方式去渲染我们的微应用。</p>
<ul>
<li>嵌套渲染场景</li>
</ul>
<p><video controls height='100%' width='100%' src="media/17280334440663/20220331164435.mp4"></video></p>
</li>
<li>
<p>多应用同时渲染：同一时刻可展示多个子应用，子应用更像是一个业务组件而不是应用。</p>
<p><figure><img src="media/17280334440663/17281450820703.jpg" alt="v2-cc82a2a5a6fbe5c141af9dd5b42622ee_1440w" /><figcaption>v2-cc82a2a5a6fbe5c141af9dd5b42622ee_1440w<figcaption></figure></p>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转微前端3】需要关注的问题]]></title>
    <link href="https://www.bwrong.cn/17280334039483.html"/>
    <updated>2024-10-04T17:16:43+08:00</updated>
    <id>https://www.bwrong.cn/17280334039483.html</id>
    <content type="html"><![CDATA[
<p>虽然qiankun已经提供了微前端的一些基本能力，但是在使用过程中还是有很多问题需要关注。</p>
<h2><a id="%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E8%A7%84%E5%88%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目架构规划</h2>
<ul>
<li>Monorepo：多应用管理可以使用<a href="https://lerna.js.org/">lerna</a>或者<a href="https://pnpm.io/zh/">pnpm</a>。</li>
</ul>
<p><figure><img src="media/17280334039483/17281450561380.png" alt="image-20220406225206585" /><figcaption>image-20220406225206585<figcaption></figure></p>
<ul>
<li>
<p>Git subtree或者多仓库：在子应用较多的情况可采用此方式，缺点是每次子应用变更后，聚合库还得同步一次变更。</p>
<p><figure><img src="media/17280334039483/17281450561404.jpg" alt="18091274-44952db2fd681a3d" /><figcaption>18091274-44952db2fd681a3d<figcaption></figure></p>
</li>
</ul>
<h2><a id="%E5%BA%94%E7%94%A8%E6%8B%86%E5%88%86%E7%B2%92%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用拆分粒度</h2>
<p>微应用的拆与合思考：拆的是系统复杂度，合的是系统复用度。</p>
<p>拆分的时候可以从平台差异、页面结构、产品业务方面考虑。并不是越细越好，业务关联紧密的功能单元应该做成一个微应用，反之关联不紧密的可以考虑拆分成多个微应用。</p>
<h2><a id="%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>样式隔离</h2>
<p>使用qiankun默认的沙箱，仅能确保单实例场景子应用之间的样式隔离，但是无法确保主应用跟子应用、或者多实例场景的子应用样式隔离。目前还没有完美的解决方案，如果遇到样式污染问题，可以考虑如下方案：</p>
<ul>
<li>命名规范+命名空间，可以尝试开启experimentalStyleIsolation（实验阶段）。</li>
<li>ShadowDom：可以开启strictStyleIsolation严格模式，启用ShadowDom，但是这并不是一个可以无脑使用的方案，可能还会有一些其他问题，如子应用的弹窗挂载到body上时样式丢失。</li>
<li>CSS In JS</li>
<li>CSSModule</li>
</ul>
<h2><a id="%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据通信</h2>
<p>应用间尽量避免通信，减少耦合性，如果两个应用间有频繁的通信需求，说明这两个微应用本身就是服务于同一个业务场景，合并成一个微应用可能会更合适。</p>
<p><strong>微前端通信方式：</strong></p>
<ul>
<li><strong>基于 URL</strong>：使用简单、通用性强，但能力较弱，不适用复杂的业务场景。</li>
<li><strong>基于 Props</strong>：最核心的通信能力，能够满足一些简单的场景。适用于主子应用共享组件、公共方法调用等。</li>
<li><strong>GlobalState</strong>：基于发布订阅模式实现，能够满足比较复杂的场景。</li>
<li><strong>本地Storage</strong>：仅适合静态通信场景，且 JSON.stringify()可能会造成数据丢失。</li>
</ul>
<h2><a id="%E6%9D%83%E9%99%90%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>权限处理</h2>
<p>主应用负责身份验证，拿到授权信息后下发到各微应用中，各应用再根据拿到的授权信息过滤各自路由信息。</p>
<p><figure><img src="media/17280334039483/17281450561413.webP" alt="img" /><figcaption>img<figcaption></figure></p>
<h2><a id="%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>资源共享</h2>
<h3><a id="%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>统一管理维护</h3>
<p>将公共资源提取到一个地方，避免多个地方维护，但是仍然会多次打包。可以通过如下两种方式：</p>
<ul>
<li>file或link方式</li>
</ul>
<p><figure><img src="media/17280334039483/17281450561420.png" alt="image-20220406235834667" /><figcaption>image-20220406235834667<figcaption></figure></p>
<ul>
<li>git仓库或者私服</li>
</ul>
<p><figure><img src="media/17280334039483/17281450561439.png" alt="image-20220406235948554" /><figcaption>image-20220406235948554<figcaption></figure></p>
<h3><a id="%E4%BE%9D%E8%B5%96%E6%8F%90%E5%8F%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>依赖提取</h3>
<p>在一个团队中，技术栈相对固定，所以统一技术栈很多基础依赖相对是固定的，但是默认情况下每个应用都会重复打包一次，会造成重复下载，影响运行性能。例如，如果每个微应用都包括自己的 Vue 副本，那么用户就得多次下载 Vue。</p>
<p>在进行如下改造之前，先确认是否有此必要，因为它会增加应用间的耦合性（如技术栈、依赖版本必须一致） ，而这是和微前端思想相悖的，</p>
<ul>
<li>cdn或者将公共依赖抽离成单独的应用或者文件引用。</li>
<li>由主应用下发（props或者window），需要处理子应用单独运行时依赖的来源问题。</li>
</ul>
<h2><a id="%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>部署与资源路径问题</h2>
<h3><a id="%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>部署方案</h3>
<ul>
<li>主应用和微应用部署到同一个服务器（同一个 IP 和端口）。</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">└── html/                     # 根文件夹
    ├── child/                # 存放所有微应用的文件夹
    |   ├── app1/         
    |   ├── app2/      
    ├── index.html            # 主应用的index.html
    ├── css/                  # 主应用的css文件夹
    ├── js/                   # 主应用的js文件夹
</code></pre>
<pre class="line-numbers"><code class="language-js">registerMicroApps([
  {
    name: 'app1',
    entry: '/child/app1/', // http://localhost:8080/child/app1/
    container: '#container',
    activeRule: '/child-app1',
  },
  {
    name: 'app2',
    entry: '/child/app2/', // http://localhost:8080/child/app2/
    container: '#container',
    activeRule: '/child-app2',
  }
],
</code></pre>
<ul>
<li>主应用和微应用部署在不同的服务器，使用 Nginx 代理访问。</li>
</ul>
<pre class="line-numbers"><code class="language-nginx">/app1/ {
  proxy_pass http://www.b.com/app1/;
  proxy_set_header Host $host:$server_port;
}
</code></pre>
<pre class="line-numbers"><code class="language-js">registerMicroApps([
  {
    name: 'app1',
    entry: '/app1/', // http://localhost:8080/app1/
    container: '#container',
    activeRule: '/child-app1',
  },
],
</code></pre>
<h3><a id="%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>资源路径错误</h3>
<p>在src代码中引用public资源会有问题，资源尽量放到src中，让webpack处理，注入publicPath。</p>
<pre class="line-numbers"><code class="language-vue">&lt;template&gt;
  &lt;img src=&quot;../../assets/images/logo.png&quot; alt=&quot;&quot;&gt;
  &lt;div class=&quot;img-test&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;img-test2 test&quot; :style=&quot;`background:url(${require('../../assets/images/logo.png')})`&quot;&gt;&lt;/div&gt;
	&lt;!-- 路径错误 --&gt;
  &lt;img src=&quot;/logo.png&quot; class=&quot;test&quot; alt=&quot;&quot;&gt;
&lt;/template&gt;
&lt;style scoped&gt;
  .img-test{
    background: url('../../assets/images/logo.png') no-repeat;
    background-size: 100% 100%;
    width: 100px;
    height: 100px;
  }
&lt;/style&gt;
</code></pre>
<h2><a id="%E5%BA%94%E7%94%A8%E4%B9%8B%E9%97%B4%E8%B7%B3%E8%BD%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用之间跳转</h2>
<p>在微应用中如果要进行应用间跳转，不能直接使用微应用的router，可以有如下几种方式：</p>
<ul>
<li>将跳转动作上抛给主应用，由主应用进行切换。</li>
<li>将主应用router下发到微应用，微应用使用该router进行跳转动作。</li>
<li>使用原生方法改变url（不建议，会造成页面刷新）。</li>
</ul>
<h2><a id="%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他问题</h2>
<ul>
<li>VueDevtools调试微应用问题，需要手动处理，但是还是会存在失效问题。</li>
</ul>
<p><figure><img src="media/17280334039483/17281450561452.png" alt="image-20220407171516398" /><figcaption>image-20220407171516398<figcaption></figure></p>
<ul>
<li>对vite构建的微应用支持还有缺陷，因为Vite暂时还不支持运行时修改资源路径和ESModule导致沙箱失效。</li>
<li>各应用间的风格和交互逻辑应该统一，因为对用户来说我们的应用仍然是一体的，要避免应用间给用户造成撕裂感。</li>
<li>运行差异性处理：如果微应用需要单独运行，需要考虑集成运行和单独运行的差异性，做一些hack兼容处理。</li>
</ul>

]]></content>
  </entry>
  
</feed>
